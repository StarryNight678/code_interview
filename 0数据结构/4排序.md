
# 排序

## 内部排序

8大内部排序方法
![](http://www.lishiyu.cn/content/uploadfile/201409/1ae11410928597.jpg)

排序复杂度总结：

![](http://upload-images.jianshu.io/upload_images/273973-19cf4a1e58b6ebaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 待排序记录的存储方式：

1. 顺序表：存放在地址连续的一组存储单元中，记录之间的关系由存储位置决定，排序必须移动记录；**顺序表**
1. 静态链表：记录之间的关系由指针指示，排序不用移动记录，指向修改指针；**链表排序**
1. 附加地址：待排序记录本身存储在一组地址连续的存储单元内，同时附设一个指示记录存储位置的地址向量，排序过程中不移动记录，而移动地址向量中这些记录的地址，在排序结束后，再按照地址向量中的值调整记录的存储位置。**地址排序**

### 插入排序

1. Straight inserting based sorting (直接插入排序)

	稳定  
	平均复杂度 O（N^2）  
	最坏复杂度 O（N^2）  
	空间复杂度O（1）

	```
	void sort(int arr[],int size)
	{
		int tmp;
		int j;
		for (int i=1;i<size;i++)
		{
			tmp=arr[i];
			j=i-1;
			while ( tmp < arr[j] && j>=0)
			{
				arr[j+1]=arr[j];
				j--;
			}
			arr[j+1]=tmp;
		}
	}
	```

1. Dichotomy inserting based sorting (折半插入排序)

	**减少了比较的次数**
	由于插入排序的基本操作是在有序表中进行查找和插入，而查找的过程是可以用折半查找来实现的。由此实现的排序称为折半插入排序。
	性能分析：
	空间效率：同上
	时间效率：仅减少了比较次数，移动记录次数不变。
	折半插入排序是一个稳定的排序方法。

1. Two way inserting based sorting (二路插入排序)
	在2-路插入排序中，移动记录的次数约为n2/8。
	2-路插入排序需要n个辅助存储空间。

![](http://i.imgur.com/jttK2ZB.png)


1. Shell sorting (希尔排序)  又称为缩小增量排序
	![](http://i.imgur.com/uncahqv.png)
	
    先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序“时，再对全体记录进行一次直接插入排序，就可以完成整个的排序工作。

    不稳定  
	平均复杂度 O（N*logN）  
	最坏复杂度 O（N^3）  
	空间复杂度O（1）

    ```
    //希尔排序
	void xier(int arr[],int size,int d)
	{
		int  tmp;
		int Len[]={5,2,1};//递增的长度
		int LenLength=3;
		for (int a=0;a<LenLength;a++)
		{
			int len=Len[a];
			for (int i=len;i<size;i++)
			{
				tmp=arr[i];
				int j=i-len;
				while ( tmp < arr[j]  && j>=0)
				{
					arr[j+len]=arr[j];
					j=j-len;
				}
				arr[j+len]=tmp;
			}
		}
	}
    ```

- 总结

当序列基本有序时，直接插入排序的效率比较高。当个数很少时效率也比较高。

### Bubble sorting (冒泡排序)

稳定  
平均复杂度 O（N^2）  
最坏复杂度 O（N^2）  
空间复杂度O（1）

```
//冒泡排序
void maopao(int arr[],int size)
{
	for (int i=0;i<size-1;i++)
	{
		for (int j=0;j<size-1-i;j++)
		{
			if (arr[j]>arr[j+1])
			{
				int tmp=arr[j+1];
				arr[j+1]=arr[j];
				arr[j]=tmp;
			}
		}
	}
}

```


### Quick sorting (快速排序)

快速排序过程：

1. 首先任意选取一个记录作为枢轴（或支点）(Pivot)，然后按下述原则重新排列其一记录：	将所有关键字小于它的记录都安置在它之前，将所有关键字大于它的记录安置在它之后。
1. 于是以该枢轴记录所在的位置i作分界线，将整个序列分成两个子序列。这个过程称为一趟快速排序。
1. 然后分别对于两个子序列作同样的操作，重复这个过程，直到子序列不可再分就完成了记录的排序工作。

![](http://i.imgur.com/gJK2lID.png)
```
//快排
void kuaipai(int arr[],int arr_begin,int arr_end)
{
	if (arr_begin<=arr_end)
	{
		int flag=arr[arr_begin];
		int m=arr_begin;
		int n=arr_end;
		while(m<n)
		{
			while (arr[n]>=flag  && m<n)
			{
				n--;
			} 
			
			if (m<n)
			{
				arr[m]=arr[n];
			}

			while(arr[m]<=flag && m<n)
			{
				m++;
			} 
			if(m<n)
			{
				arr[n]=arr[m];	
			}
		}
		arr[m]=flag;
		kuaipai(arr,0,m-1);
		kuaipai(arr,m+1,arr_end);
	}
}
```

### 树形选择排序

树形选择排序 (Tree Selection Sort)，又称锦标赛排序 (Tournament Sort)。


每次两两比较的结果是把关键码小者作为优胜者上升到双亲结点，称这种**比赛树为胜者树**。

![](http://i.imgur.com/v4MZhCA.png)

![](http://i.imgur.com/ys52weE.png)

锦标赛排序构成的树是满的完全二叉树，其深度为 log2(n+1)，其中 n 待排序元素个数。
除第一次选择具有最小关键码的对象需要进行 n-1 次关键码比较外，重构胜者树选择具有次小、再次小关键码对象所需的关键码比较次数均为 O(log2n)。总关键码比较次数为O(nlog2n)。
对象的移动次数不超过关键码的比较次数，所以锦标赛排序总的时间复杂度为O(nlog2n)。


稳定  
平均复杂度 O（N*logN）

### 堆排序

锦标赛排序的时间复杂度为O(nlogN)。缺点是使用了较多的辅助空间，并且和“最大值”进行了多余的比较。1964年Willioms 提出了堆排序。

堆顶元素必为序列中n个元素的最小值（或最大值）。如果在输出堆顶的最小值后，使得剩余n-1个元素的序列重又建成一个堆，则得到次小值。反复执行便能得到所有记录的有序序列，这个过程称为堆排序。

现在需要研究两个问题：

### 如何由一个无序序列建成一个堆；
	解决方案：自下而上调整

 	![](http://i.imgur.com/sa8iVCk.png)

 	![](http://i.imgur.com/KXKmZ7T.png)

### 如何在输出堆顶元素后，调整剩余元素使之成为一个新的堆。
	解决方案：自上而下调整

	![](http://i.imgur.com/l7FNH7h.png)

	![](http://i.imgur.com/G5GdCRx.png)


不稳定
时间复杂性为O(nlogn)
空间复杂性为O(1)



### 归并排序

归并的含义：归并是将两个或两个以上的有序表合并成一个有序表。

![](http://i.imgur.com/B0a2qKB.png)

归并排序: 

假设初始的序列含有n个记录，可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2或1的有序子序列；再两两归并，如此重复直到得到一个长度为n的有序序列为止。

稳定
很少用于内部排序
时间复杂性为O(nlogn)
空间复杂性为,和待排记录等量的空间


## [三种线性排序算法的比较](https://www.byvoid.com/zhs/blog/sort-radix)

1. 基数排序
1. 桶排序
1. 计数排序

### 基数排序


基数排序则是一种借助于多关键字排序思想对单逻辑关键字进行排序的方法，不需要进行关键字的比较。

基数排序是借助“分配”和“收集”两种基本操作对单逻辑关键字进行排序的一种内部排序方法。
有的逻辑关键字可以看成是若干个关键字复合而成的。例如数值和字符串。

最高位优先法(Most Significant Digit First): 最高位关键字比较

第二种方法是从最次位关键字Kd-1开始进行排序，称为最低位优先法 (Least Significant Digit First)。

 两种方法的特点：MSD算法需要逐层分成若干个子序列，而LSD算法进行排序时，不必分成子序列，但对Ki(0 ≤ i ≤ d-1)进行排序时，只能用**稳定的排序方法。**

 第一趟分配对最低数位关键字进行，改变记录指针值将链表中的记录分配至10个链队列中去，每个队列中的记录关键字的个位数相等；第一趟收集是改变所有非空队列的队尾的指针域，令其指向下一个非空队列的队头记录，重新将10个队列中的记录链成一个链表；第二趟分配和收集是针对十位数位进行的，过程和个位数位相同。其他位数一样。


![](http://i.imgur.com/pZMQO0L.png)

![](http://i.imgur.com/6HehM1v.png)

![](http://i.imgur.com/snyI9Vx.png)


假设每个记录含d个关键字，每个关键字的取值范围为rd，则每趟分配的时间复杂度为O(n)，每一趟收集的时间复杂度为O(rd)，则总的时间复杂度为O(d×(n+rd))。
空间复杂度：增加了n+2rd个指针域的空间。


有1,000,000个8位的整数要进行排序，使用快速排序法，至少需要nlogn次比较，即2千万次，用基数排序法则只需要8*(1,000,000+10)，约8百万次。


### 计数排序

计数排序是一种算法复杂度 O(n) 的排序方法，适合于小范围集合的排序。
已知数的范围

计数排序是一个类似于桶排序的排序算法，其优势是对已知数量范围的数组进行排序。它创建一个长度为这个数据范围的数组C，C中每个元素记录要排序数组中对应记录的出现个数。这个算法于1954年由 Harold H. Seward 提出。

下面以示例来说明这个算法

假设要排序的数组为 A = {1,0,3,1,0,1,1}

这里最大值为3，最小值为0，那么我们创建一个数组C，长度为4.

然后一趟扫描数组A，得到A中各个元素的总数，并保持到数组C的对应单元中。

比如0 的出现次数为2次，则 C[0] = 2;

1 的出现次数为4次，则C[1] = 4

![](http://images.cnblogs.com/cnblogs_com/eaglet/WindowsLiveWriter/107c96fa4f00_C680/image_thumb.png)

由于C 是以A的元素为下标的，所以这样一做，A中的元素在C中自然就成为有序的了，这里我们可以知道 顺序为 0,1,3 (2 的计数为0)

然后我们把这个在C中的记录按每个元素的计数展开到输出数组B中，排序就完成了。

也就是 B[0] 到 B[1] 为0  B[2] 到 B[5] 为1 这样依此类推。


稳定
时间复杂度为O(N+K)
空间复杂度为O(N+K)

当K不是很大时，这是一个很有效的线性排序算法。更重要的是，它是一种稳定排序算法，即排序后的相同值的元素原有的相对位置不会发生改变(表现在Order上)，这是计数排序很重要的一个性质，就是根据这个性质，我们才能把它应用到基数排序。

### 桶排序

桶排序 (Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。

排序过程：

1. 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶
1. 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序
1. 将各个桶中的数据有序的合并起来

设有数组 array = [29, 25, 3, 49, 9, 37, 21, 43]，那么数组中最大数为 49，先设置 5 个桶，那么每个桶可存放数的范围为：09、1019、2029、3039、40~49，然后分别将这些数放人自己所属的桶，如下图：

![](http://bubkoo.qiniudn.com/bucket-sort-1.png)

然后，分别对每个桶里面的数进行排序，或者在将数放入桶的同时用插入排序进行排序。最后，将各个桶中的数据有序的合并起来，如下图：

![](http://bubkoo.qiniudn.com/bucket-sort-2.png)

### 总结

**基于比较的排序算法是不能突破O(NlogN)**

N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为**log(N!)=O(NlogN)(斯特林公式)。**



## 外部排序