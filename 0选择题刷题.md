# 选择题刷题

## C/C++

## 内存对齐

内存对齐规定：结构体的总大小为结构体最宽基本类型成员大小的整数倍
可见最宽的是float是4.，数组的形式只是多个数据放在一起而已。
联合体里面总共是5个字节，要为4的倍数所以为8个字节，
所以为8+8+4=20

```c
struct stu
{
union{
char bj[5];
int bh[2];
} class;
char xm[8];
float cj;
}xc;
```

sizeof(xc) 大小是20;

![](http://uploadfiles.nowcoder.com/files/20140920/104_1411220705386_%E5%9B%BE%E7%89%872.jpg)

首先，#pragma pack(2)   强制设定为2字节对齐

int4,enum4,union14(因为pack(2)),总22

1. 如何引用一个已经定义过的全局变量？用extern关键字方式
1. 下面有关虚函数和非虚函数的区别说法错误的是？父类的指针访问虚函数访问的是父类的方法.动态绑定。
o% 表示8进制进行输出int m=0123; m已经是8进制不需要进行转换  而n=123是10进制 需要进行8进制转换 得173
void* malloc(unsigned int size);申请的内存在()动态存储区

---

```c
int main(){
  int a;float b,c;
  scanf("%2d%3f%4f",&a,&b,&c);
  printf("\na=%d,b=%d,c=%f\n",a,b,c);
}
```

printf函数执行的时候，会先把这三个数字压入栈里，然后再执行打印。压入栈的时候按照数据本身的长度来，首先把c和b压入，并且每一个都是8个字节（printf自动转化为double）。然后再压入a是4个字节。然后再执行打印。打印的时候按照用户指定的格式来出栈。首先打印a，a打印正常。然后又打印4个字节长度的b，在栈里面由于b长度是八个字节，并且b目前是64位的表示方式，数据的后面全是0.（float 变double），电脑是小端存储方式，0存储在距离a近的地方。打印b的时候，打印的4个字节都是0.然后再打印c，c用正常的方式打印，会一下子读取8个字节，正好，读出来的八个字节前面四个字节全是0，自己可以算一下，实在太小了，因此为0.
栈底                                          栈顶
高字节。。。。。。。。。。。低字节
4321     0000      765     0000         98
4字节   4字节    4字节    4字节      4字节
             打印c                 打印b      打印a
附：浮点数（单精度的float和双精度的double）在内存中以二进制的科学计数法表示，表达式为N = 2^E * F；其中E为阶码（采用移位存储），F为尾数。
float和double都由符号位、阶码、尾数三部分组成，float存储时使用4个字节，double存储时使用8个字节。各部分占用位宽如下所示：
             符号位     阶码      尾数     长度
float              1           8         23      32
double          1         11        52       64

---

dynamic_cast<>用于C++类继承多态间的转换，分为：

```c
已知下面的class层次,其中每一个class都定义有一个
default constructor和一个virtual destructor;

class X{...};
class A{...};
class B:public A{...};
class C:public B{...};
class D:public X,public C{...};
```

下面()执行dynamic_cast会失败   *pb=new B;D *pd=dynamic_cast<D*>(pb);

A <- B <- C <- D <- E
 
A* a = new C; // 本质
B* b = dynamic_cast<B*> (a); // 成功，因为B是C的父类
E* e = dynamic_cast<E*> (a); // 失败，因为E是C的子类

---

下面说法错误的是()

1. 在组合时,为了保证成员对象被正确清除,在组合类的析构函数中需要显式调用其成员对象的析构函数
1. 在类的继承层次中,可以自动进行向上和向下类型转换.而且都是安全的

成员类对象在离开作用域的时候会调用其自身的析构函数，并不需要我们手动delete，就将其看做一个基本的局部对象即可。除非在构造的时候用了动态类存分配，这又是另外一回事了。

C++的派生类如果要覆盖一个继承到的成员函数,在基类中需要将该函数声明为virtual
D：正确，也是《Effective C++》第37条，如果子类要重写父类方法，需要将父类该方法声明为virtual，实现RTTI。当然你可以不这样干，结果就是静态绑定。补充一点，重写就叫覆盖。如果没有virtual就是隐藏。

```c

```

```c

```
