# 数据库

# 第一章 绪论

重点:

1. 数据库系统的四个基本概念
1. 数据模型（概念模型/层次，网状，关系模型）
1. 数据库系统的三级模式与两级映像


1. 数据(Data)
1. 数据库(DataBase)
1. 数据库管理系统(DBMS)
1. 数据库系统(DBS)

### 数据模型

**数据模型是数据库系统的核心和基础。**


模型：现实世界中某个对象特征的模拟和抽象



### 概念模型

对现实世界的事物符号化的描述，为计算机处理做准备。常用的概念模型是E-R Entity-Relationship)图

实体型：矩形
属性：  椭圆
联系：  菱形

### 数据模型：现实世界数据特征的抽象

数据结构
数据操作
数据的约束条件

1. 层次数据模型
1. 网状数据模型
1. 关系数据模型
1. 面向对象数据模型

- 层次模型

多对多联系在层次模型中的表示
方法一： 冗余结点法
方法二：虚拟结点法

两种方法的比较：

冗余结点法可以随意改变结点的存储位置，但增加了额外存储空间，容易造成数据的不一致性。
虚拟结点法改变结点存储位置后必须修改虚结点的指针，但不会产生数据的不一致性。

- 完整约束性

进行插入操作时,如果没有相应的双亲结点值就不能插入子女结点值。  
进行删除操作时,如果删除双亲结点值,则相应的子女结点值也被同时删除。  
进行修改操作时,应修改所有相应记录,以保证数据的一致性。

- 存储

方法一：邻接表法（顺序存储，树的前序遍历）
方法二：链接法 （子女-兄弟链接法）
方法三：链接法 （层次序列链接法）

层次模型优缺点:

- 优点

 层次数据模型本身比较简单。
 查询效率高,性能优于关系模型,不低于网状模型。  
 层次数据模型提供了良好的完整性支持

- 缺点

 现实世界中很多联系是非层次性的，层次模型只能通过引入
  冗余数据(易产生不一致性)或创建非自然的数据组织(引入 
  虚拟结点)来解决。
 对插入和删除操作的限制多
 查询子女结点必须通过双亲结点
 层次命令趋于程序化

### 网状模型

它具备两个条件：
 (1)允许一个以上的结点无双亲     
 (2)一个结点可以有多于一个的双亲


将多对多联系分解成两个一对多联系
对于带属性的联系单独作为一组记录

- 存储结构

1. 常用方法：
1. 单向链接
1. 双向链接
1. 环状链接
1. 向首链接

- 网状模型的优缺点

优点

 能够更为直接地描述现实世界。 
 具有良好的性能,存取效率较高

缺点

 结构比较复杂,随着应用环境的扩大,数据库的结构变复杂,不利于最终用户掌握。
 其DDL,DML语言复杂,用户不容易使用

### 关系模型

数据结构：二维表


域：属性的取值范围。
关系模式：对关系结构的描述，定义如下：
		关系名（属性1，属性1，…，属性n ）
例： 学生（学号，姓名，年龄，性别，系，年级）

- 关系必须是规范化的，满足一定的规范条件

**最基本的规范条件：关系的每一个分量必须是一个不可分的数据项,  不允许表中还有表**

- 存储模型

存储结构
实体和联系都作为数据文件来存储。

关系模型

优点

建立在严格的数学概念的基础上
概念单一。数据结构简单、清晰，用户易懂易用
关系模型的存取路径对用户透明


缺点

存取路径对用户透明，导致查询效率降低。
为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度

### 数据库系统结构的划分方法

从数据库管理系统角度看：三级模式结构
从数据库最终用户角度看

1. 集中式结构(单用户结构、主从式结构)
1. 分布式结构
1. 客户／服务器(Client/Server)结构
1. 并行结构


模式（Schema）

1. 数据库逻辑结构和特征的描述
1. 是型的描述
1. 反映的是数据的结构及其联系
1. 模式是相对稳定的


### 三级模式与两级映像


1. 外模式：数据的**局部逻辑结构**,用户模式,用户和数据库系统的接口,用户的数据视图
1. 模式：  数据的**全局逻辑结构**,所有用户的公共数据视图,**全部数据的逻辑结构和特征的描述。**

1. 内模式：数据的**存储结构**.存储模式,物理结构和存储方式的描述，是数据在数据库内部的表示方式。


数据库的二级映像功能与数据独立性
外模式/模式映像---逻辑独立性
模式/内模式映像---物理独立性


# 第二章 关系数据库

## 2.1.关系数据结构及形式化定义


域（Domain）
笛卡尔积（Cartesian Product） 
关系（Relation）

- 笛卡尔积(没有交换律)
```
例如，A={a,b}, B={0,1,2}，则
A×B={(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}
B×A={(0, a), (0, b), (1, a), (1, b), (2, a), (2, b)}
```

D1 x D2 x…x Dn的子集叫做在域D1,D2,..Dn上的关系。


几个概念：
1. 超码(Super Key)：任意一个候选码的超集。
1. 候选码(Candidate Key)：能唯一标识元组的属性(组)。
1. **主码(Primary Key)**：多个候选码中选定一个作主码。
1. 主属性(Prime Attribute)：候选码中的诸属性。
1. 非主属性(Non-Key Attribute)：不出现在任何候选码中的属性

关系分类

1. 基本关系（基本表）--------数据库中的表 
1. 查询表--------------------查询结果集 
1. 视图----------------------多个表导出（虚表） 

关系数据库
型：关系数据库模式
值：某一个时刻具体的实例

## 关系操作

查询：选择，投影，连接， 除，并，交，差，笛卡尔积

更新：增加，删除，修改

## 关系的完整性

1.实体完整性：若属性A是基本关系R的主属性，则属性A不能取空值
2.参照完整性:表内属性间的参照也要有存在的值
3.用户定义的完整性,通常由RDBMS的Check约束提供这类检查。


## 2.4.关系代数


1. + 
1. -
1. 笛卡尔积
1. 选择: **行的集合**,多个关系式通过`^`连接
	![](http://i.imgur.com/OK7pj0Q.png)

1. 投影：**列的运算**,从关系中选出若干列构成新的关系
	
	![](http://i.imgur.com/ItKcDaR.png)

	注：投影之后不仅取消了原关系中的某些列，而且还可能取消某些元组（避免重复行）

1. 连接: 从两个关系的笛卡尔积中选取属性间满足一定条件的元组

	![](http://i.imgur.com/JWUwqq7.png)

	等值连接：A=B 
	自然连接：AB为相同属性组，且去除重复的属性且等值。（取消重复列）



	**外连接**,连接中舍弃的元组也进行保留的连接称做外连接
	![](http://i.imgur.com/lUxM6Fo.png)
	**左外连接**,保留左边关系R中舍弃的元组的连接称做左外连接
	![](http://i.imgur.com/sGjPH8P.png)
	**右外连接**,保留右边关系S中舍弃的元组的连接称做右外连接

1. 除(除操作是同时从行和列角度进行运算)
	
	找到A和B的相同值后,组成的表.找其余值.
	![](http://i.imgur.com/cmhnP2E.png)

	- 非常清楚的例子
	![](http://i.imgur.com/H9uzclW.png)


1. 例子

	查询只选修C2和C4课程的学生学号。

	R1：至少选修了C2和C4课程的学生学号。(除法操作)

	R2：选修了C2和C4以外其他课的学生学号。

	R = R1 – R2

- 传统的集合运算:

1. 并(Union)
1. 交(Intersection)
1. 差(Difference)
1. 广义笛卡尔积(Extended Cartesian Product)

- 专门的关系运算：

1. 选择(Select)
1. 投影(Project)
1. 连接(Join)
1. 除(Divide)


## 2.5.关系演算



# 第三章  关系数据库标准语言SQL

重点:

1. 数据查询(难)　
1. 数据更新　　
1. 视图


## 3.1.SQL概述

SQL:结构化查询语言(Structured Query Language)

SQL功能	动词

1. 数据定义	CREATE，DROP，ALTER 
1. 数据查询	SELECT
1. 数据更新	INSERT，UPDATE，DELETE
1. 数据控制	GRANT，REVOKE

名称:

database
table
view
index

revoke 撤销


## 3.3.数据定义

1. 视图的定义、修改和删除（外模式）
1. 数据库的定义，修改和删除（模式）
1. 基本表的定义、修改和删除（模式）
1. 索引的定义、修改和删除（内模式）


SQL Server中的SQL注释符号：

单行注释：`--`（双连字符）

多行注释：`/* ... */`

![](http://i.imgur.com/WnGx3kj.png)


- 创建表 CREATE TABLE 

```
CREATE TABLE  <表名>  (
   <列名>    <数据类型>   [完整性约束] 
[，<列名>    <数据类型>   [完整性约束]] … 
[, <表级完整性约束>]   ) ; 
```
- 完整性约束条件

CHECK约束，规则Primary key, Foreign key， Unique,  Not null, default value 

这些完整性约束条件被存入系统的数据字典中

```
CREATE TABLE S (
         Sno int(10) ,
         sname text  not null,
         ssex CHAR(3) , 
         sdep   int(3) ,
         sage   int(3) ,
         PRIMARY KEY (Sno)
         );


CREATE TABLE C (
	     cno char(10) ,
         cname text ,
         credit int,
         cpno  char(10),
         PRIMARY KEY (cno) 
         );
     

CREATE TABLE SC (
         Sno int(10) ,
         cno char(10),
         grade int(10),
         FOREIGN  KEY  (Sno) REFERENCES S(Sno),
		 FOREIGN  KEY  (cno) REFERENCES C(cno),
		 PRIMARY KEY (Sno,Cno)
		 );
      
```


数据类型的属性
```
MySQL关键字	含义
NULL	数据列可包含NULL值
NOT NULL	数据列不允许包含NULL值
DEFAULT	默认值
PRIMARY KEY	主键
AUTO_INCREMENT	自动递增，适用于整数类型
UNSIGNED	无符号
CHARACTER SET name	指定一个字符集
```


- 基本表的修改 ALTER TABLE 

```
	ALTER TABLE <表名>
[ ADD <新列名> <数据类型> [ 完整性约束 ] ]
[ DROP <完整性约束名> <列名>]
[ ALTER COLUMN <列名> <数据类型> ]；


添加列
ALTER TABLE Student ADD Scome DATETIME ；
改变列的数据类型
ALTER TABLE Student ALTER column Sage  SMALLINT；
删除学生姓名必须取唯一值的约束。
ALTER TABLE Student DROP constraint IX_sname
```

- 表的删除 DROP TABLE 

```
 DROP TABLE <表名>; 

```

- 建立索引 CREATE INDEX 

```
CREATE [UNIQUE] [CLUSTER/NONCLUSTERED] INDEX 
<索引名> ON <表名>（<列名>，[<次序>][，<列名>
[<次序 >]]…）

CREATE UNIQUE INDEX Stusno ON Student(Sno);
CREATE UNIQUE INDEX SCno ON SC(Sno ASC, Cno DESC);

在Student表的Sname（姓名）列上建立一个聚簇索引， 
     而且Student表中的记录将按照Sname值的升序存放。
CREATE CLUSTER INDEX Stusname ON Student(Sname)；


```

UNIQUE ：每个索引值只对应一个唯一的数据记录

CLUSTER：

1. 索引项的顺序与表中物理顺序一致,聚集索引的        最低一级（叶级）包含实际的数据行 ;
1. 实质对表中记录依列名进行排序，
1. 在一个基本表上最多只能建立一个聚簇索引
1. 更新时要重排序。


[网易笔试](https://www.nowcoder.com/questionTerminal/71db5f45024c439a9f862ff7fd5b7ba9
)
有关聚集索引的描述，说法正确的是？

1. 有存储实际数据
1. 没有存储实际数据
1. 物理上连续
1. 逻辑上连续
1. 可以用B树实现
1. 可以用二叉排序树实现

正确答案：A C E

在RDBMS中索引一般采用B+树、HASH索引来实现。（参照《数据库系统概论 第四版 王珊 P90）
**无索引的查询：顺序依次遍历表中的每行**



- 删除索引

```
DROP INDEX  <索引名>
```

- 查看索引

```
show index from S;
```


## 3.4.数据查询


- 数据的查询

```
Select [ ALL|DISTINCT ]  <输出属性列表> 
From          <一个或多个数据库表或视图>
[Where        <查询条件> ]
[Group By     <分组条件>[HAVING <条件表达式>] ]
[Order By     <结果排序> [ASC|DESC]

DISTINCT 取消重复的行.
单表
select * from student where sage>18 AND sdept =‘cs’ 
Select * from student where sdept IN (‘IS’,’MA’,’CS’)
Select  * from student where sname LIKE ‘刘__‘ 
Select  * from student where sname LIKE ‘刘%‘ 
(%任意字符串(长度可以为0) __任意单字符（汉字需两个）)
select * from sc where grade IS NULL

order by: asc或者desc， 缺省值为升序
select sno,grade  from sc  where cno='3'  order by grade desc

select *  from student   order by sdept,sage desc

```
![](http://i.imgur.com/NeHEzRE.png)

- GROUP BY 对查询结果分组

值相等的为一组，常与集函数一起使用。
HAVING 条件只能作用组
WHERE 作用于表、视图

```
select cno,count(sno) from sc  group by cno

select sno  from sc  
   where  sno between  95001 and 95100
   group  by sno having count(*)>2
```

- 连接查询

若一个查询同时涉及两个以上的表，则称这样的查询为连接查询

```
连接条件：[<表名1>].<列名1> <比较运算符> [<表名2>].<列名2> 

连接种类:
等值连接/自然连接/非等值连接
自身连接
外连接
复合条件连接

查询每个学生及其选修课程的情况。
SELECT  Student.*, SC.*
FROM    Student, SC
WHERE   Student.Sno = SC.Sno；  //等值连接

SELECT  Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade
FROM    Student, SC
WHERE  Student.Sno = SC.Sno；  //自然连接

自身连接
Select  a.cno,b.cpno from course a，course b Where a.cpno=b.cno
外连接
Select student.sno, sname,ssex,sage,sdept,cno,grade
from   student LEFT OUT JOIN sc
On  student.sno = sc.sno 

OUTER JOIN/LEFT OUT JOIN

```

- 连接查询

```
SELECT  Student.Sno, student.Sname
   FROM   Student, SC
   WHERE  Student.Sno = SC.Sno AND     // 连接谓词 
   SC.Cno= '2' AND  　　　　    // 其他限定条件
   SC.Grade > 90；       　     // 其他限定条件

```

- 嵌套查询

```
Select sname 			外层查询/父查询
from student
   where sno IN  
	(select sno 			内层查询/子查询
	from sc 
	where cno=‘2’)	

子查询的SELECT：不能使用ORDER BY子句

```
- ANY

```
SELECT Sname，Sage
FROM    Student
WHERE Sage < ANY (SELECT  Sage
                              FROM    Student
                              WHERE Sdept= ' IS ')
               AND Sdept <> ' IS '

```
- 存在量词

```
SELECT Sname
FROM   Student 
WHERE   EXISTS
	( SELECT  *
   	  FROM SC 
	  WHERE Sno =  Student.Sno AND  Cno= '1')；

```

查询选修了全部课程的学生学号。

```
select  sno
from    sc
group by sno
having count(cno) = 
       (select count(cno) from c)
```

- 集合查询

并操作(UNION)
交操作(INTERSECT)
差操作(EXCEPT)

```
SELECT Sno
FROM SC
WHERE Cno='1'
UNION
SELECT Sno
FROM SC
WHERE Cno= '2'
```

查询平均成绩最高的学生学号。

```
SELECT  Sno
FROM   SC
GROUP  BY  Sno
HAVING   AVG(Grade) >=ALL ( SELECT  AVG(Grade)
			       FROM   SC
				GROUP  BY  Sno) ;

注：集函数没有复合功能，即不能写成 MAX(AVG(Grade)) 。

```


## 3.5.数据更新

- 插入
```
insert 表名 (属性) values(常量);
insert S (sno,sname) values (1, wang);
```

- 修改
```
update 表名 set 列名 = XX  where XX

updat S set age=22 where sno='20000'
```

insert S (sno,sname, ssex,sdep,sage) values (1, 'li','男',1,23);

- 删除数据

`delete from 表名 where XX;`


## 3.6.视图

视图是逻辑表,不存在.基本表导出来的表.基本表变化,视图变化.

创建视图
```
create view  视图名  (列)  as 子查询

CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition

```

查询视图,像普通表一样.

删除视图
DROP VIEW view_name


**使用视图的优势？视图可以将多个复杂关联表，提取出我们需要的信息，优化查询速度。**

1. 简化操作
1.  机密数据提供安全保护
1. 清晰表达查询

# 第四章 




存储过程
视图
触发器 





















## Mysql命令

- 大小写问题
MySQL在Linux下数据库名、表名、列名、别名大小写规则是这样的：

1. 数据库名与表名是严格区分大小写的；
1. 表的别名是严格区分大小写的；
1. 列名与列的别名在所有的情况下均是忽略大小写的；
1. 变量名也是严格区分大小写的；

- MySQL在Windows下都不区分大小写。


MySQL的数据类型
[ MySQL中数据类型介绍](http://blog.csdn.net/bzhxuexi/article/details/43700435)

主要包括以下五大类：

1. 整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT

```
MySQL数据类型	含义（有符号）
tinyint(m)	1个字节  范围(-128~127)
smallint(m)	2个字节  范围(-32768~32767)
mediumint(m)	3个字节  范围(-8388608~8388607)
int(m)	4个字节  范围(-2147483648~2147483647)
bigint(m)	8个字节  范围(+-9.22*10的18次方)
int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。
```

1. 浮点数类型：FLOAT、DOUBLE、DECIMAL

```
MySQL数据类型	含义
float(m,d)	单精度浮点型    8位精度(4字节)     m总个数，d小数位
double(m,d)	双精度浮点型    16位精度(8字节)    m总个数，d小数位
设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。
DECIMAL 十进制.
浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 
decimal(m,d) 参数m<65 是总个数，d<30且 d<m 是小数位。
```

1. 字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB

```
字符串(char,varchar,_text)
MySQL数据类型	含义
char(n)	固定长度，最多255个字符
varchar(n)	固定长度，最多65535个字符
tinytext	可变长度，最多255个字符
text	可变长度，最多65535个字符
mediumtext	可变长度，最多2的24次方-1个字符
longtext	可变长度，最多2的32次方-1个字符

varchar可直接创建索引
text类型不能有默认值。 
```

1. 日期类型：Date、DateTime、TimeStamp、Time、Year
```
日期时间类型

MySQL数据类型	含义
date	日期 '2008-12-2'
time	时间 '12:25:36'
datetime	日期时间 '2008-12-2 22:06:44'
timestamp	自动存储记录修改时间
```

1. 其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等

设一个字段定义为float(5,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。








### mysql 命令

1. 进入 mysql -u root -p
1. 状态 status
1. 建立一个新库 create database new; 
1. 显示所有数据库 show databases; 
1. 显示所有表 show tables;  
1. drop database if exists school;  
1. 使用数据库 use new; 
1. 建立新表

	create table app_user(  
	username varchar(20),  
	password varchar(255),  
	primary key(username)); 

1. 显示表结构 `describe app_user;/desc app_user; `
desc 表名;  
show columns from 表名;  
describe 表名;  

1. 插入测试数据

	insert into app_user values('tomcat' , '123');  
	insert into app_user values('yeeku' , '123'); 

1. 退出MySQL管理界面  quit

```
+--------------------+
| Database           |
+--------------------+
| information_schema |
| dbtest             |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
```

create database dbtest;
use dbtest;



```
CREATE TABLE S (
         Sno int(10) ,
         sname text  not null,
         ssex CHAR(3) , 
         sdep   int(3) ,
         sage   int(3) ,
         PRIMARY KEY (Sno)
         );


CREATE TABLE C (
	     cno char(10) ,
         cname text ,
         credit int,
         cpno  char(10),
         PRIMARY KEY (cno) 
         );
     

CREATE TABLE SC (
         Sno int(10) ,
         cno char(10),
         grade int(10),
         FOREIGN  KEY  (Sno) REFERENCES S(Sno),
		 FOREIGN  KEY  (cno) REFERENCES C(cno),
		 PRIMARY KEY (Sno,Cno)
		 );

create unique index   sindex  on S (sno asc);  
```