# C++ 学习

## 第二章 C++简单程序设计

### C++语言概述
### 基本数据类型和表达式
### 数据的输入与输出
### 算法的基本控制结构
### 自定义数据类型


1. 短整	short	16	
1. 基本 	 int	32  
1. 长整	long	32	
1. 字符型  char  占1个字节

###　变量的存储类型

auto
属于一时性存储，其存储空间可以被若干变量多次覆盖使用。

register
存放在通用寄存器中。

extern
在所有函数和程序段中都可引用。

static
在内存中是以固定地址存放的，在整个程序运行期间都有效。

typedef  已有类型名  新类型名表;

枚举类型

```c
#include <iostream>
using namespace std;
enum game_result {WIN, LOSE, TIE, CANCEL};
int main()
{ game_result result;
   enum game_result omit = CANCEL;
   int count;
   for (count = WIN ; count <= CANCEL ; count++) 
   { result = (game_result)count;
      if (result == omit)
      { cout << "The game was cancelled\n";  }
      else 
      { cout << "The game was played ";
         if (result == WIN)   cout << "and we won!";
         if (result == LOSE)  cout << "and we lost.";
         cout << "\n";
      }
   }
   return 0;
}

```

结构体

联合体: 共用相同的内存单元.

```c
union uarea
{  char   c_data;
   short  s_data;
   long   l_data;
}
```

无名联合没有标记名

联合体的全部数据成员共享同一组内存单元.

1. sizeof strlen 区别

sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。

    它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
    由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
    具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：

    1. 数组——编译时分配的数组空间大小；
    1. 指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
    1. 类型——该类型所占的空间大小；
    1. 对象——对象的实际占用空间大小；
    1. 函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。

 strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。

 它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。

```c
eg1、char arr[10] = "What?";
int len_one = strlen(arr);
int len_two = sizeof(arr); 
cout << len_one << " and " << len_two << endl; 

输出结果为：5 and 10
点评：sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。strlen只关心存储的数据内容，不关心空间的大小和类型。

eg2、char * parr = new char[10];
int len_one = strlen(parr);
int len_two = sizeof(parr);
int len_three = sizeof(*parr);
cout << len_one << " and " << len_two << " and " << len_three << endl;
    输出结果：23 and 4 and 1
```

1. 面向对象的思想
1. OOP的基本特点
1. 类概念和声明
1. 对象
1. 构造函数
1. 析构函数
1. 内联成员函数
1. 拷贝构造函数
1. 类的组合

封装、隐藏、继承与派生。

公有类型成员:任何外部函数都可以访问公有类型数据和函数。

私有类型成员:在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。

保护类型:与private类似，其差别表现在继承与派生时对派生类的影响不同

内联成员函数:

1. 将函数体放在类的声明中。
1. 使用inline关键字

多态：同一名称，不同的功能实现方式。

- 构造函数

构造函数的作用是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。
在对象创建时由系统自动调用。
如果程序中未声明，则系统自动产生出一个默认形式的构造函数
允许为内联函数、重载函数、带默认形参值的函数

- 拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用

当用类的一个对象去初始化该类的另一个对象时系统自动调用拷贝构造函数实现拷贝赋值

类名（类名 &对象名）；//拷贝构造函数

```
Point(int xx=0,int yy=0){X=xx; Y=yy;}
Point(Point&  p);

Point A(1,2);
Point B(A); //拷贝构造函数被调用
```

当函数的返回值是类对象时，系统自动调用拷贝构造函数

析构函数


组合:类中的成员数据是另一个类的对象

构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）

# 第五章  C++程序的结构

通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。

友元函数和友元类。

友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员

数据指针指向数据存储区，而函数指针指向的是程序代码存储区


```
char (*fp)[3];
fp = new char[2][3];
```


不同继承方式的影响主要体现在：

1. 派生类成员对基类成员的访问权限
1. 通过派生类对象对基类成员的访问权限

派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。

通过派生类的对象只能访问基类的public成员。

私有继承(private):
基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可直接访问。

保护继承(protected):

protected 成员的特点与作用:

对建立其所在类对象的模块来说，它与 private 成员的性质相同。
对于其派生类来说，它与 public 成员的性质相同。
既实现了数据隐藏，又方便继承，实现代码重用。

析构函数的调用次序与构造函数相反。

虚基类

主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.
为最远的派生类提供惟一的基类成员，而不重复产生多次拷贝

# 第八章  多态性

多态性:
多态性是指发出同样的消息被不同类型的对象接收时有可能导致完全不同的行为。

多态的实现：
函数重载
运算符重载
虚函数



运算符重载
虚函数
纯虚函数
抽象类

虚函数:

本质：不是重载声明而是覆盖。
调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。

抽象类

带有纯虚函数的类称为抽象类:


函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。
声明方法：
template <typename  标识符> 
函数声明

类模板

template <模板参数表>
class 类名
{类成员声明}

template <class T>  
   //类模板：实现对任意类型数据进行存取
class Store
{ private:
   T item; //用于存放任意类型的数据
   int haveValue;//用于标记item是否已被存入内容
  public:
   Store(void); //默认形式（无形参）的构造函数
   GetElem(void);  //提取数据函数
   void PutElem(T x);//存入数据函数
};


STL是泛型程序设计的一个范例 

1. 容器(container)

1. 迭代器(iterator)

1. 算法（algorithms）

1. 函数对象（function object）

- 七种基本容器：

向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）


适配器

三种类型的适配器：
容器适配器
用来扩展7种基本容器，它们和顺序容器相结合构成栈、队列和优先队列容器
迭代器适配器
函数对象适配器。

顺序容器

插入方法
push_front()，push_back()，insert()，运算符“=”
删除方法
pop() ，erase()，clear()
迭代访问方法
使用迭代器
其他顺序容器访问方法（不修改访问方法）
front()，back()，下标[]运算符

容器适配器也是类模板，它使用容器存储元素，但提供了比标准容器更严苛的接口。


顺序容器——向量


最重要的三个输出流是
ostream
ofstream
ostringstream

ofstream类支持磁盘文件输出



1. ->  * 区别

对象名.* 类成员指针名
或：

对象指针名—>*类成员指针名


1. new  malloc区别


1. public  protected private 访问区域

[腾讯求职经历(后附大量面试题)](https://www.nowcoder.com/discuss/260)


面试题汇总（干货）
  
  
计算机网络相关
   1 TCP三次握手、四次挥手 2 TCP滑动窗口机制 3 TCP拥塞控制机制 4 socket模型 

  
C/C++相关
   1 虚析构、模板和宏 2 虚函数实现机制 3
  vector与list的区别，map是如何实现的，查找效率是多少 4 extern 关键字有什么用 5 malloc和new的区别，能否malloc(1.2G)
  
linux以及操作系统相关
   1 内存池实现 2 进程间通信机制 3 Linux ps命令，以及看内存当前使用状态的命令 4
  进程与线程的区别，共享的数据 5 进程的内存空间
  
算法与数据结构
  （手写代码实现）
   1 大整数加、减、乘、除、求模运算实现 2 很多整数，找其中出现次数最多的那个数 3
  单链表翻转（两个指针如何实现）、查找、删除、插入以及双向链表、有序链表合并 4
  判断一个整数是否是2的整数次幂.(n&(n-1)) 5   二分查找（注意边界条件） 6
  常见排序算法的实现以及稳定性（快排跟归并考的很多） 7 字符串翻转（O(n)）、匹配（KMP算法） 8
  最长递增子序列（nlogn的算法） 9   链表判断是否有环，环的入口，两个链表是否相交（快慢指针）。 10
  指定一个数组，求2个数的和等于指定的和（某一个数），如果是3,4,5，n个等于个的和（某一个数）呢？（可以看作背包问题） 
  11 跳台阶问题
  
其他
   1 红黑树的性质以及插入和删除 2 解析XML文件 3
  千万级的用户，提供一个服务，该服务有很多模块，现在有一个底层模块需要优化，问怎么实现，在不影响其他服务模块以及用户体验的情况下。（面IEG）
  4 卡特兰数以及公式推导（应多很多） 5   未知大小的文件，翻转整个文件 6
  如果内存中有个cache存储qq号和最近登录时间问怎么样做hit和淘汰 7   检测短信敏感词 8 大数据问题 9 C++、java和PHP有什么本质区别


[腾讯一面面经](https://www.nowcoder.com/discuss/11423)


1. 问项目、实习经历（将近50分钟） 
2. 创建一个server有哪些步骤（socket层面）？如果使用IO复用呢？ 
3. select和epoll有什么区别？ 
4. TCP三次握手和四次挥手？为什么要四次挥手？ 
5. linux查看CPU使用情况用什么命令？查看内存呢？ 
6. load average后面三个数分别表示什么？ 
7. CPU的%sy, %us分别表示什么？什么情况会改变%sy？

