# C++ 学习

## 第二章 C++简单程序设计

### C++语言概述
### 基本数据类型和表达式
### 数据的输入与输出
### 算法的基本控制结构
### 自定义数据类型


1. 短整	short	16	
1. 基本 	 int	32  
1. 长整	long	32	
1. 字符型  char  占1个字节


###　变量的存储类型

auto
属于一时性存储，其存储空间可以被若干变量多次覆盖使用。

register
存放在通用寄存器中。

extern
在所有函数和程序段中都可引用。

static
在内存中是以固定地址存放的，在整个程序运行期间都有效。

typedef  已有类型名  新类型名表;

枚举类型

```c
#include <iostream>
using namespace std;
enum game_result {WIN, LOSE, TIE, CANCEL};
int main()
{ game_result result;
   enum game_result omit = CANCEL;
   int count;
   for (count = WIN ; count <= CANCEL ; count++) 
   { result = (game_result)count;
      if (result == omit)
      { cout << "The game was cancelled\n";  }
      else 
      { cout << "The game was played ";
         if (result == WIN)   cout << "and we won!";
         if (result == LOSE)  cout << "and we lost.";
         cout << "\n";
      }
   }
   return 0;
}

```

结构体

联合体: 共用相同的内存单元.

```c
union uarea
{  char   c_data;
   short  s_data;
   long   l_data;
};
```

无名联合没有标记名

联合体的全部数据成员共享同一组内存单元.

1. sizeof strlen 区别

sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。

它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：

1. 数组——编译时分配的数组空间大小；
1. 指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
1. 类型——该类型所占的空间大小；
1. 对象——对象的实际占用空间大小；
1. 函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。

strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。

它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。

```c
eg1、char arr[10] = "What?";
int len_one = strlen(arr);
int len_two = sizeof(arr); 
cout << len_one << " and " << len_two << endl; 

输出结果为：5 and 10
点评：sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。strlen只关心存储的数据内容，不关心空间的大小和类型。

eg2、char * parr = new char[10];
int len_one = strlen(parr);
int len_two = sizeof(parr);
int len_three = sizeof(*parr);
cout << len_one << " and " << len_two << " and " << len_three << endl;
    输出结果：23 and 4 and 1
```

1. 面向对象的思想
1. OOP的基本特点
1. 类概念和声明
1. 对象
1. 构造函数
1. 析构函数
1. 内联成员函数
1. 拷贝构造函数
1. 类的组合

封装、隐藏、继承与派生。

公有类型成员:任何外部函数都可以访问公有类型数据和函数。

私有类型成员:在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。

保护类型:与private类似，其差别表现在继承与派生时对派生类的影响不同

内联成员函数:

1. 将函数体放在类的声明中。
1. 使用inline关键字

多态：同一名称，不同的功能实现方式。

- 构造函数

构造函数的作用是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。
在对象创建时由系统自动调用。
如果程序中未声明，则系统自动产生出一个默认形式的构造函数
允许为内联函数、重载函数、带默认形参值的函数

- 拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用

当用类的一个对象去初始化该类的另一个对象时系统自动调用拷贝构造函数实现拷贝赋值

类名（类名 &对象名）；//拷贝构造函数

```
Point(int xx=0,int yy=0){X=xx; Y=yy;}
Point(Point&  p);

Point A(1,2);
Point B(A); //拷贝构造函数被调用
```

当函数的返回值是类对象时，系统自动调用拷贝构造函数

析构函数


组合:类中的成员数据是另一个类的对象

构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）

# 第五章  C++程序的结构

通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。

友元函数和友元类。

友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员

数据指针指向数据存储区，而函数指针指向的是程序代码存储区


```
char (*fp)[3];
fp = new char[2][3];
```


不同继承方式的影响主要体现在：

1. 派生类成员对基类成员的访问权限
1. 通过派生类对象对基类成员的访问权限

派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。

通过派生类的对象只能访问基类的public成员。

私有继承(private):
基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可直接访问。

保护继承(protected):

protected 成员的特点与作用:

对建立其所在类对象的模块来说，它与 private 成员的性质相同。
对于其派生类来说，它与 public 成员的性质相同。
既实现了数据隐藏，又方便继承，实现代码重用。

析构函数的调用次序与构造函数相反。

虚基类

主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.
为最远的派生类提供惟一的基类成员，而不重复产生多次拷贝

# 第八章  多态性

多态性:
多态性是指发出同样的消息被不同类型的对象接收时有可能导致完全不同的行为。

多态的实现：
函数重载
运算符重载
虚函数



运算符重载
虚函数
纯虚函数
抽象类

虚函数:

本质：不是重载声明而是覆盖。
调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。

抽象类

带有纯虚函数的类称为抽象类:


函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。
声明方法：
template <typename  标识符> 
函数声明

类模板

template <模板参数表>
class 类名
{类成员声明}

template <class T>  
   //类模板：实现对任意类型数据进行存取
class Store
{ private:
   T item; //用于存放任意类型的数据
   int haveValue;//用于标记item是否已被存入内容
  public:
   Store(void); //默认形式（无形参）的构造函数
   GetElem(void);  //提取数据函数
   void PutElem(T x);//存入数据函数
};


STL是泛型程序设计的一个范例 

1. 容器(container)

1. 迭代器(iterator)

1. 算法（algorithms）

1. 函数对象（function object）

- 七种基本容器：

向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）


适配器

三种类型的适配器：
容器适配器
用来扩展7种基本容器，它们和顺序容器相结合构成栈、队列和优先队列容器
迭代器适配器
函数对象适配器。

顺序容器

插入方法
push_front()，push_back()，insert()，运算符“=”
删除方法
pop() ，erase()，clear()
迭代访问方法
使用迭代器
其他顺序容器访问方法（不修改访问方法）
front()，back()，下标[]运算符

容器适配器也是类模板，它使用容器存储元素，但提供了比标准容器更严苛的接口。


顺序容器——向量


最重要的三个输出流是
ostream
ofstream
ostringstream

ofstream类支持磁盘文件输出

##  面试问题

1. ->  * 区别

对象名.* 类成员指针名
或：

对象指针名—>*类成员指针名


1. malloc/free与new/delete的区别

- 相同点：

都可用于申请动态内存和释放内存

本质区别
malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。

- 不同点：
操作对象有所不同。

malloc与free是C++/C 语言的标准库函数，new/delete 是C++的运算符。对于非内部数据类的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。

用法上也有所不同。

函数malloc 的原型如下：
void * malloc(size_t size);
用malloc 申请一块长度为length 的整数类型的内存，程序如下：
int *p = (int *) malloc(sizeof(int) * length);
我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。

1、malloc 返回值的类型是void *，所以在调用malloc 时要显式地进行类型转换，将void * 转换成所需要的指针类型。
2、 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。
函数free 的原型如下：

void free( void * memblock );
为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么free
对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p连续操作两次就会导致程序运行错误。


1、new自动计算需要分配的空间，而malloc需要手工计算字节数
2、new是类型安全的，而malloc不是，比如：

```c
int* p = new float[2]; // 编译时指出错误
int* p = malloc(2*sizeof(float)); // 编译时无法指出错误
```

是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：

第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
第三部：对象构造完成后，返回一个指向该对象的指针。
使用delete操作符来释放对象内存时会经历两个步骤：

第一步：调用对象的析构函数。
第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。
总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：




1. 特征	new/delete	malloc/free
1. 分配内存的位置	自由存储区	堆
1. 内存分配成功的返回值	完整类型指针	void*
1. 内存分配失败的返回值	默认抛出异常	返回NULL
1. 分配内存的大小	由编译器根据类型计算得出	必须显式指定字节数
1. 处理数组	有处理数组的new版本new[]	需要用户计算数组的大小后进行内存分配
1. 已分配内存的扩充	无法直观地处理	使用realloc简单完成
1. 是否相互调用	可以，看具体的operator new/delete实现	不可调用new
1. 分配内存时内存不足	客户能够指定处理函数或重新制定分配器	无法通过用户代码进行处理
1. 函数重载	允许	不允许
1. 构造函数与析构函数	调用	不调用

- 联系

既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。



1. public  protected private 访问区域

[腾讯求职经历(后附大量面试题)](https://www.nowcoder.com/discuss/260)


面试题汇总（干货）
  
  
## 计算机网络相关

1. TCP三次握手、四次挥手 

TCP(Transmission Control Protocol)　传输控制协议

位码即tcp标志位,

有6种标示:

1. SYN(synchronous建立联机)
1. ACK(acknowledgement 确认)
1. PSH(push传送)
1. FIN(finish结束)
1. RST(reset重置)
1. URG(urgent紧急)
1. Sequence number(顺序号码)
1. Acknowledge number(确认号码)

第一次握手：主机A发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包

第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。

完成三次握手，主机A与主机B开始传送数据。

完成三次握手，主机A与主机B开始传送数据。

在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器 进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据.


![](http://upload-images.jianshu.io/upload_images/533518-020ada1863d368a5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](http://hi.csdn.net/attachment/201108/7/0_131271823564Rx.gif)

![](http://hi.csdn.net/attachment/201108/7/0_1312719804oSkK.gif)

![](http://hi.csdn.net/attachment/201108/7/0_1312719833030b.gif)

四次分手：

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。

（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。

（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。

（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

![](http://upload-images.jianshu.io/upload_images/533518-2e624cf66132b589.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？

这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

2．为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？

这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。

2. TCP滑动窗口机制 

3. TCP拥塞控制机制 

早期的TCP协议只有基于窗口的流控制（flow control）机制,采用滑动窗口.

TCP拥塞控制机制

TCP的拥塞控制由4个核心算法组成：

1. “慢启动”（Slow Start）、
1. “拥塞避免”（Congestion voidance）、
1. “快速重传 ”（Fast Retransmit）、
1. “快速恢复”（Fast Recovery）。

具体的流程图可以参见：http://www.eventhelix.com/RealtimeMantra/Networking/，这里我会把自己的理解尽可能详细的列出来。为了方便起见，把发送端叫做client，接收端为server，每个segment长度为512字节，阻塞窗口长度为cwnd（简化起见，下面以segment为单位），sequence number为seq_num，acknowledges number为ack_num。通常情况下，TCP每接收到两个segment，发送一个ack

慢启动：最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。具体来说，当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。这样cwnd的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已

拥塞避免：从慢启动可以看到，cwnd可以很快的增长上来，从而最大程度利用网络带宽资源，但是cwnd不能一直这样无限增长下去，一定需要某个限制。TCP使用了一个叫慢启动门限(ssthresh)的变量，当cwnd超过该值后，慢启动过程结束，进入拥塞避免阶段。对于大多数TCP实现来说，ssthresh的值是65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是cwnd的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd的大小加1，cwnd的值就随着RTT开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。

快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包
离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的ACK，那么根据TCP
的ACK机制就表明有一个数据包离开了网络，于是cwnd加1。如果能够严格按照该原则那么网络中很少会
发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。

前面讲过标准的重传，client会等待RTO时间再重传，但有时候，不必等这么久也可以判断需要重传，例如：client一次发送8个segment，seq_num起始值为100000，但是由于网络原因，100512丢失，其他的正常，则server会响应4个ack(100512)(为什么呢，tcp会把接收到的其他segment缓存起来，ack_num必须是连续的)，这时候，client接收到四个重复的ack，它完全有理由判断100512丢失，进而重传，而不必傻等RTO时间了。这就是快速重传。
那么，什么是快速恢复呢？我们通常认为client接收到3个重复的ack后，就会开始快速重传，但是，如果还有更多的重复ack呢，如何处理？这就是快速恢复要做的，事实上，我们可以把快速恢复看作是快速重传的后续处理，它不是一种单独存在的形态。


4. socket模型 

1. 阻塞I/O（blocking I/O）
1. 非阻塞I/O （nonblocking I/O）
1. I/O复用(select 和poll) （I/O multiplexing）
1. 信号驱动I/O （signal driven I/O (SIGIO)）
1. 异步I/O （asynchronous I/O (the POSIX aio_functions)）


简介：主要是select和epoll；对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听；


connect, send, recv

- 同步非阻塞模型

而是每隔一段时间就去收发室检查信箱；
这样，老陈也能在间隔时间内休息一会，或喝杯荼，看会电视，做点别的事情；

- I/O复用(异步阻塞)模式

频繁地去收发室对老陈来说太累了，在间隔的时间内能做的事也很少，而且取到信的效率也很低.
于是，老陈向小区物业提了建议；
小区物业改进了他们的信箱系统：
住户先向小区物业注册，之后小区物业会在已注册的住户的家中添加一个提醒装置，
每当有注册住房的新的信件来临，此装置会发出 "新信件到达"声，
提醒老陈去看是不是自己的信到了。

- 这就是异步阻塞模型；

在这种模型中，配置的是非阻塞 I/O，然后使用阻塞 select 系统调用来确定一个 I/O 描述符何时有操作。
使 select 调用非常有趣的是它可以用来为多个描述符提供通知，而不仅仅为一个描述符提供通知。
对于每个提示符来说，我们可以请求这个描述符可以写数据、有读数据可用以及是否发生错误的通知

 
- 信号驱动I/O模型

老陈接收到新的信件后，一般的程序是：
打开信封----掏出信纸 ----阅读信件----回复信件 ......
为了进一步减轻用户负担，小区物业又开发了一种新的技术：
住户只要告诉小区物业对信件的操作步骤，小区物业信箱将按照这些步骤去处理信件，
不再需要用户亲自拆信 /阅读/回复了！



## C/C++相关

1. 虚析构、模板和宏 

做基类的类的析构函数一般都是虚函数
这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数


由于宏定义只是用宏名对一个字符串进行简单的替换，因此如果在宏定义命令后加了分号，将会连同分号一起进行置换。



2. 虚函数实现机制 
3.  vector与list的区别，map是如何实现的，查找效率.

数组 队列  

红黑树


4.  extern 关键字有什么用 

定义：外部变量是指在函数或者文件外部定义的全局变量。外部变量定义必须在所有的函数之外，且只能定义一次。

5.. malloc和new的区别，能否malloc(1.2G)
  
## linux以及操作系统相关

1. 内存池实现 
2. 进程间通信机制 
3. Linux ps命令，以及看内存当前使用状态的命令
4. 进程与线程的区别，共享的数据 
5. 进程的内存空间
  
## 算法与数据结构

1. 大整数加、减、乘、除、求模运算实现 
2. 很多整数，找其中出现次数最多的那个数 
3. 单链表翻转（两个指针如何实现）、查找、删除、插入以及双向链表、有序链表合并 
4. 判断一个整数是否是2的整数次幂.(n&(n-1)) 
5.   二分查找（注意边界条件） 
6.   常见排序算法的实现以及稳定性（快排跟归并考的很多） 
7. 字符串翻转（O(n)）、匹配（KMP算法） 
8.   最长递增子序列（nlogn的算法） 
9.   链表判断是否有环，环的入口，两个链表是否相交（快慢指针）。 
10.   指定一个数组，求2个数的和等于指定的和（某一个数），如果是3,4,5，n个等于个的和（某一个数）呢？（可以看作背包问题） 
11. 跳台阶问题
  
## 其他
   
1. 红黑树的性质以及插入和删除 
2. 解析XML文件 
3. 千万级的用户，提供一个服务，该服务有很多模块，现在有一个底层模块需要优化，问怎么实现，在不影响其他服务模块以及用户体验的情况下。（面IEG）
4. 卡特兰数以及公式推导（应多很多） 
5. 未知大小的文件，翻转整个文件 
6. 如果内存中有个cache存储qq号和最近登录时间问怎么样做hit和淘汰 
7. 检测短信敏感词 
8. 大数据问题 
9. C++、java和PHP有什么本质区别


[腾讯一面面经](https://www.nowcoder.com/discuss/11423)


1. 问项目、实习经历（将近50分钟） 
2. 创建一个server有哪些步骤（socket层面）？如果使用IO复用呢？ 
3. select和epoll有什么区别？ 




4. TCP三次握手和四次挥手？为什么要四次挥手？ 
5. linux查看CPU使用情况用什么命令？查看内存呢？

free -m 
6. load average后面三个数分别表示什么？ 
load average: 0.06, 0.60, 0.48
系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。

7. CPU的%sy, %us分别表示什么？什么情况会改变%sy？

Cpu(s):  1.8%us,  5.1%sy, 

Cpu(s): 0.3% us
用户空间占用CPU百分比
1.0% sy
内核空间占用CPU百分比

