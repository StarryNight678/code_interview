# C++ 学习

## 第一章


## 第二章 C++简单程序设计

### 反码

正数的反码与原码表示相同。

负数的反码与原码有如下关系：
符号位相同(仍用1表示)，其余各位取反(0变1，1变0).
反码中零的表示也不惟一

### 计算机中的补码表示法

负数的补码由该数反码的末位加 1 求得
对补码再求补即得到原码


short unsigned short          2字节

int unsigned int         4字节

long unsigned long         4字节

auto
属于一时性存储，其存储空间可以被若干变量多次覆盖使用。

register
存放在通用寄存器中。

extern
在所有函数和程序段中都可引用。

static
在内存中是以固定地址存放的，在整个程序运行期间都有效。


## 判断瑞年

IsLeapYear = ((year % 4 == 0 &&  year % 100 != 0)||(year % 400 == 0));

### C++语言概述
### 基本数据类型和表达式
### 数据的输入与输出
### 算法的基本控制结构
### 自定义数据类型

## [数组指针和指针数组的区别](http://www.cnblogs.com/hongcha717/archive/2010/10/24/1859780.html)


数组指针（也称行指针）
定义 int (*p)[n];
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。

如要将二维数组赋给一指针，应这样赋值：

```c
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
```

所以数组指针也称指向一维数组的指针，亦称行指针。

指针数组
定义 int *p[n];
[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。

```c
如要将二维数组赋给一指针数组:
int *p[3];
int a[3][4];
for(i=0;i<3;i++)
p[i]=a[i];
```

这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。

这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
比如要表示数组中i行j列一个元素：

```c
*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]
```

1. 短整	short	16	
1. 基本 	 int	32  
1. 长整	long	32	
1. 字符型  char  占1个字节


## 变量的存储类型

auto
属于一时性存储，其存储空间可以被若干变量多次覆盖使用。

register
存放在通用寄存器中。

extern
在所有函数和程序段中都可引用。

static
在内存中是以固定地址存放的，在整个程序运行期间都有效。

typedef  已有类型名  新类型名表;

`typedef double area,volume;`

```c
	do
	{
		XXX
	} 
	while (n != 0);

```

### 枚举类型

```c
#include <iostream>
using namespace std;
enum game_result {WIN, LOSE, TIE, CANCEL};
int main()
{ game_result result;
   enum game_result omit = CANCEL;
   int count;
   for (count = WIN ; count <= CANCEL ; count++) 
   { result = (game_result)count;
      if (result == omit)
      { cout << "The game was cancelled\n";  }
      else 
      { cout << "The game was played ";
         if (result == WIN)   cout << "and we won!";
         if (result == LOSE)  cout << "and we lost.";
         cout << "\n";
      }
   }
   return 0;
}

```

结构体

联合体: 共用相同的内存单元.

```c
union uarea
{  char   c_data;
   short  s_data;
   long   l_data;
};
```

无名联合没有标记名

联合体的全部数据成员共享同一组内存单元.

1. sizeof strlen 区别

sizeof(...)是运算符，在头文件中typedef为unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。

它的功能是：获得保证能容纳实现所建立的最大对象的字节大小。
由于在编译时计算，因此sizeof不能用来返回动态分配的内存空间的大小。实际上，用sizeof来返回类型以及静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。
具体而言，当参数分别如下时，sizeof返回的值表示的含义如下：

1. 数组——编译时分配的数组空间大小；
1. 指针——存储该指针所用的空间大小（存储该指针的地址的长度，是长整型，应该为4）；
1. 类型——该类型所占的空间大小；
1. 对象——对象的实际占用空间大小；
1. 函数——函数的返回类型所占的空间大小。函数的返回类型不能是void。

strlen(...)是函数，要在运行时才能计算。参数必须是字符型指针（char*）。当数组名作为参数传入时，实际上数组就退化成指针了。

它的功能是：返回字符串的长度。该字符串可能是自己定义的，也可能是内存中随机的，该函数实际完成的功能是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。返回的长度大小不包括NULL。

## 引用传递

声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。
一旦一个引用被初始化后，就不能改为指向其它对象。

## 默认形参

默认形参值必须从右向左顺序声明

```c
char arr[10] = "What?";
int len_one = strlen(arr);
int len_two = sizeof(arr); 
cout << len_one << " and " << len_two << endl; 

输出结果为：5 and 10
点评：sizeof返回定义arr数组时，编译器为其分配的数组空间大小，不关心里面存了多少数据。strlen只关心存储的数据内容，不关心空间的大小和类型。

eg2、char * parr = new char[10];
int len_one = strlen(parr);
int len_two = sizeof(parr);
int len_three = sizeof(*parr);
cout << len_one << " and " << len_two << " and " << len_three << endl;
    输出结果：23 and 4 and 1
```

# 第4章 类与对象

1. 面向对象的思想
1. OOP的基本特点
1. 类概念和声明
1. 对象
1. 构造函数
1. 析构函数
1. 内联成员函数
1. 拷贝构造函数
1. 类的组合


```c
class 类名称
{
   public:
             公有成员（外部接口）
   private:
             私有成员
   protected:
             保护型成员
}; //注意这个分号
```

```c
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3 #include<string.h>
  4 #include<iostream>
  5 #include<string>
  6 using namespace std;
  7 
  8 
  9 class CC
 10 {
 11         public:
 12 int a;
 13 
 14 };
 15 
 16 
 17 int main()
 18 {
 19    CC c;
 20    c.a=1;
 21    cout<<c.a<<endl;
 22 }
~      
```

私有类型成员

**如果紧跟在类名称的后面声明私有成员，则关键字private可以省略**


## 内联

在类中声明内联成员函数的方式：

1. 将函数体放在类的声明中。
1. 使用inline关键字

封装、隐藏、继承与派生。

公有类型成员:任何外部函数都可以访问公有类型数据和函数。

私有类型成员:在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。

保护类型:与private类似，其差别表现在继承与派生时对派生类的影响不同

内联成员函数:

1. 将函数体放在类的声明中。
1. 使用inline关键字

多态：同一名称，不同的功能实现方式。

- 构造函数

构造函数的作用是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。
在对象创建时由系统自动调用。
如果程序中未声明，则系统自动产生出一个默认形式的构造函数
允许为内联函数、重载函数、带默认形参值的函数

- 拷贝构造函数是一种特殊的构造函数，其形参为本类的对象引用

当用类的一个对象去初始化该类的另一个对象时系统自动调用拷贝构造函数实现拷贝赋值

类名（类名 &对象名）；//拷贝构造函数

```
Point(int xx=0,int yy=0){X=xx; Y=yy;}
Point(Point&  p);

Point A(1,2);
Point B(A); //拷贝构造函数被调用
```

## 拷贝构造函数调用:

当用类的一个对象去初始化该类的另一个对象时系统自动调用拷贝构造函数实现拷贝赋值。
`Point B(A); //拷贝构造函数被调用`

若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。
`fun1(A); //调用拷贝构造函数`

当函数的返回值是类对象时，系统自动调用拷贝构造函数

```c
Point fun2()
{    Point A(1,2);
     return A; //调用拷贝构造函数
}
```
析构函数

## 组合

组合:类中的成员数据是另一个类的对象

```c
类名::类名(对象成员所需的形参，本类成员形参)
       :对象1(参数)，对象2(参数)，......
{  本类初始化  }
```

```c
Whole::Whole(int i,int j,int k):
            two(i),one(j),date(k)
{}
```

前向引用声明

使用前向引用声明虽然可以解决一些问题，但它并不是万能的。需要注意的是，尽管使用了前向引用声明，但是在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类的对象。请看下面的程序段：

应该记住：当你使用前向引用声明时，你只能使用被声明的符号，而不能涉及类的任何细节。

构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）



构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）

# 第五章  C++程序的结构

1. 作用域与可见性
1. 对象的生存期
1. 数据与函数
1. 静态成员
1. 共享数据的保护
1. 友元
1. 编译预处理命令
1. 多文件结构和工程

在函数内部声明静态生存期对象，要冠以关键字static 

## 静态、动态生存期

```c
#include<iostream.h>
int i=1; // i 为全局变量，具有静态生存期。
int main()   
{ static int a;// 静态局部变量，有全局寿命，局部可见。
  int b=-10; // b, c为局部变量，具有动态生存期。
  int c=0;
  void other(void);
  cout<<"---MAIN---\n";
  cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
  c=c+8;  other();
  cout<<"---MAIN---\n";
  cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
  i=i+10; other();  
}


void other(void)
{
  static int a=2;
  static int b;
   // a,b为静态局部变量，具有全局寿命，局部可见。
   //只第一次进入函数时被初始化。
  int c=10; // C为局部变量，具有动态生存期，
            //每次进入函数时都初始化。
  a=a+2; i=i+32; c=c+5;
  cout<<"---OTHER---\n";
  cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
  b=a;
}

```
## 结果

```
---MAIN---
 i: 1 a: 0 b: -10 c: 0
---OTHER---
 i: 33 a: 4 b: 0 c: 15
---MAIN---
 i: 33 a: 0 b: -10 c: 8
---OTHER---
 i: 75 a: 6 b: 4 c: 15
```

通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。

## 静态成员

1. 用关键字static声明
1. 该类的所有对象维护该成员的同一个拷贝
1. 必须在类外定义和初始化，用(::)来指明所属的类。

静态成员函数

1. 类外代码可以使用类名和作用域操作符来调用静态成员函数。
1. 静态成员函数只能直接引用属于该类的静态数据成员或静态成员函数。



## 友元函数和友元类。

友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员

数据指针指向数据存储区，而函数指针指向的是程序代码存储区

- 友元类

```c
class A
{   friend class B;
    public:
      void Display()
       {cout<<x<<endl;}
    private:
      int x;
}
class B
{   public:
      void Set(int i);
      void Display();
    private:
      A a;
};

```

```
char (*fp)[3];
fp = new char[2][3];
```

## 友元关系是单向的

不同继承方式的影响主要体现在：

1. 派生类成员对基类成员的访问权限
1. 通过派生类对象对基类成员的访问权限



使用条件编译的头文件

```c
//head.h
#ifndef  HEAD_H
  #define  HEAD_H
    …
  class Point
  {
      …
  }
      …
#endif
```

# 第六章 数组  指针与字符串

1. 数组
1. 指针
1. 动态存储分配
1. 指针与数组
1. 指针与函数
1. 字符串

数组名字是数组首元素的内存地址。
数组名是一个常量，不能被赋值

```c
static int a[10]={0,1,2,3,4,5,6,7,8,9
static int a[]={1,2,3,4,5}
static int a[10]={0,1,2,3,4};
int a[5][3];
a[0]——a00 a01 a02 a03
a[1]——a10 a11 a12 a13
a[2]——a20 a21 a22 a23

a00 a01 a02 a03  a10 a11 a12 a13   a20 a21 a22 a23
static int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
static int a[3][4]
={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
static int a[3][4]={{1},{0,6},{0,0,11}};

```

int var;
则&var 表示变量var在内存中的起始地址


# 指针常量

```c
 2     char *str1={"Hello"};
 3     char *str2={"Hello World"};
 4     char * const ptr1 =str1 ;
 5     //指针常量－－指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化
 7     ptr1 =str2; //错误 因为这是一个常量指针，改变指向的地址了
 8 
 9     printf("%s \n",*ptr1);
10     }
```

## 常量指针

```c
 1 void main(){
 2     char *str1={"Hello"};
 3     char *str2={"Hello World"};
 4     const char *ptr1 = str1;
 5     //常量指针－－指向字符串常量，所指向的字符串内容不能变，但是指向的地址可以变化
 6     
 7     ptr1=str2;// 正确 因为指向的地址是可以变化的
 8 
 9     printf("%s \n",ptr1);
10     }
11 
12 //输出 Hello World
```


```c
int a[10], *pa;
pa=&a[0]; 或 pa=a;
```

输出二维数组

```c
    for(int i=0;i<2;i++)
    {  cout<<*(array2+i)<<endl;	
	    for(int j=0;j<3;j++)
        {  cout<<*(*(array2+i)+j)<<" ";   
           //或者 cout<<array2[i][j]<<" ";
        }	

```

数据指针指向数据存储区，而函数指针指向的是程序代码存储区。


## 函数指针

```c
void (*function_pointer)(float);
void print_float(float data_to_print);
function_pointer = print_float;
function_pointer(pi);
void print_float(float data_to_print)
{	cout<<"The data to be printed is " 
      <<data_to_print<<endl;    
}
```

## 对象指针

声明形式
类名  *对象指针名；

```c
Point A(5,10);
Piont *ptr;
ptr=&A;
```
## 对象指针

通过指针访问对象成员.
对象指针名->成员名

```c
ptr->getx() 相当于 (*ptr).getx();
```

曾经出现过的错误例子

```c
class Fred;	//前向引用声明
class Barney {
   Fred x;	//错误：类Fred的声明尚不完善
 };
class Fred {
   Barney y;
 };
```

正确的程序

```c
class Fred;	//前向引用声明
class Barney {
   Fred *x;	 
 };
class Fred {
   Barney y;
 };
```

## this指针

隐含于每一个类的成员函数中的特殊指针。

明确地指出了成员函数当前所操作的数据所属的对象。
当通过一个对象调用成员函数时，系统先将该对象的地址赋给this指针，然后调用成员函数，成员函数对对象的数据成员进行操作时，就隐含使用了this指针。


```c
Point类的构造函数体中的语句：
X=xx;
Y=yy; 
相当于：
this->X=xx;
this->Y=yy;
```
动态创建

```c
Point *Ptr1=new Point;
delete  Ptr1;   
cout<<"Step Two:"<<endl;
Ptr1=new Point(1,2);
delete Ptr1
```

删除数组

```c
Point *Ptr=new Point[2]; //创建对象数组
Ptr[0].Move(5,10); //通过指针访问数组元素的成员
Ptr[1].Move(15,20); //通过指针访问数组元素的成员
cout<<"Deleting..."<<endl;
delete[ ] Ptr;  //删除整个对象数组
```

```c
char (*fp)[3];
fp = new char[2][3];
```

```c
void *malloc( size );
void free( void *memblock );

```

浅拷贝
实现对象间数据元素的一一对应复制。

深拷贝
当被复制的对象数据成员是指针类型时，不是复制该指针成员本身，而是将指针所指的对象进行复制。

## 整行输入字符串


cin.getline(字符数组名St,字符个数N,结束符);
功能：一次连续读入多个字符（可以包括空格），直到读满N个，或遇到指定的结束符（默认为'\n'）。读入的字符串存放于字符数组St中。读取但不存储结束符。
cin.get(字符数组名St,字符个数N,结束符);
功能：一次连续读入多个字符（可以包括空格），直到读满N个，或遇到指定的结束符（默认为'\n'）。读入的字符串存放于字符数组St中。既不读取也不存储结束符。


```c
{	char city[80];
	char state[80];
	int  i;
	for (i = 0; i < 2; i++)
	{ cin.getline(city,80,',');
	  cin.getline(state,80,'\n');
	}
}
```

```c
strcat（连接），strcpy（复制），
strcmp（比较），strlen（求长度），
strlwr(转换为小写）,strupr（转换为大写）
头文件<cstring>

```

# 第七章 继承与派生

- 类的继承
- 类成员的访问控制
- 单继承与多继承
- 派生类的构造、析构函数
- 类成员的标识与访问


继承的目的：实现代码重用。

派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。

- 派生类的声明

```c
class 派生类名：继承方式  基类名
{
        成员声明；
}
```

## 继承方式影响

不同继承方式的影响主要体现在：

- 派生类成员对基类成员的访问权限
- 通过派生类对象对基类成员的访问权限


## 三种继承方式

- 公有继承

1. 基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可直接访问。
1. 生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
1. 通过派生类的对象只能访问基类的public成员。

- 私有继承

1. 基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可直接访问。
1. 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
1. 通过派生类的对象不能直接访问基类中的任何成员。


- 保护继承

1. 基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可直接访问。
1. 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。
1. 通过派生类的对象不能直接访问基类中的任何成员

- 类型兼容规则

1. 派生类的对象可以被赋值给基类对象。
1. 派生类的对象可以初始化基类的引用。
1. 指向基类的指针也可以指向派生类

单一继承时的构造函数
```c
派生类名::派生类名(基类所需的形参，本类成员所需的形参):基类名(参数表)
{
        本类成员初始化赋值语句；
}；
```
多继承时的构造函数

```c
派生类名::派生类名(基类1形参，基类2形参，...基类n形参，本类形参):基类名1(参数), 基类名2(参数), ...基类名n(参数)
{
        本类成员初始化赋值语句；
}；

```

多继承且有内嵌对象时的构造函数
```c
派生类名::派生类名(基类1形参，基类2形参，...基类n形参，本类形参):基类名1(参数), 基类名2(参数), ...基类名n(参数)，对象数据成员的初始化
{
        本类成员初始化赋值语句；
}；

```
构造函数的调用顺序

1. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。
2． 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。
3． 派生类的构造函数体中的内容。

```c
class C: public B2, public B1, public B3 
{
public:	//派生类的公有成员
	C(int a, int b, int c, int d): 
       B1(a),memberB2(d),memberB1(c),B2(b)  {}
private:	//派生类的私有对象成员
	B1 memberB1;
	B2 memberB2;
	B3 memberB3;
};
int main()
{	C obj(1,2,3,4);  }
```

- 运行结果：

```c
constructing B2 2
constructing B1 1
constructing B3 *
constructing B1 3
constructing B2 4
constructing B3 *
```

- 拷贝构造函数

1. 若建立派生类对象时调用默认拷贝构造函数，则编译器将自动调用基类的默认拷贝构造函数。
1. 若编写派生类的拷贝构造函数，则需要为基类相应的拷贝构造函数传递参数。例如:`C::C(C &c1):B(c1){…}`

- 继承时的析构函数

1. 析构函数也不被继承，派生类自行声明
1. 声明方法与一般（无继承关系时）类的析构函数相同。
1. 不需要显式地调用基类的析构函数，系统会自动隐式调用。
1. 析构函数的调用次序与构造函数相反。

- 同名隐藏规则

当派生类与基类中有同名成员时：

1. 若未显式指定类名，则通过派生类对象使用的是派生类中的同名成员。
1. 如果派生类中声明了与基类成员函数同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏。
1. 如要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名限定。


## 二义性问题

1. 在多继承时，基类之间出现同名成员时，将出现访问时的二义性（不确定性）——用类名限定，或同名隐藏规则来解决。
1. 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。


解决方法一：用类名来限定c1.A::f()    或    c1.B::f()
解决方法二：同名隐藏在C 中声明一个同名成员函数f()，在f()中根据需要

## 虚基类

虚基类的引入 用于有共同基类的场合
声明 以virtual修饰说明基类例：class B1:virtual public B

作用

1. 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.
1. 为最远的派生类提供惟一的基类成员，而不重复产生多次拷贝

注意：
在第一级继承时就要将共同基类设计为虚基类。


```c
	B
B1		B1
	C

class B{ private: int b;};
class B1 : virtual public B { private: int b1;};
class B2 : virtual public B { private: int b2;};
class C : public B1, public B2{ private: float d;}
下面的访问是正确的：
C  cobj;
cobj.b;
```


派生类中的成员函数可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员。

通过派生类的对象只能访问基类的public成员。

私有继承(private):
基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可直接访问。

保护继承(protected):

protected 成员的特点与作用:

对建立其所在类对象的模块来说，它与 private 成员的性质相同。
对于其派生类来说，它与 public 成员的性质相同。
既实现了数据隐藏，又方便继承，实现代码重用。

析构函数的调用次序与构造函数相反。

虚基类

主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.
为最远的派生类提供惟一的基类成员，而不重复产生多次拷贝

# 第八章  多态性

1. 多态性
1. 运算符重载
1. 虚函数
1. 纯虚函数
1. 抽象类


多态性:
多态性是指发出同样的消息被不同类型的对象接收时有可能导致完全不同的行为。

多态的实现：

1. 函数重载
1. 运算符重载
1. 虚函数


## 运算符重载

重载为类成员函数时  参数个数=原操作数个数-1	（后置++、--除外）
重载为友元函数时  参数个数=原操作数个数，且至少应该有一个自定义类型的形参。


```c
声明形式
函数类型  operator 运算符（形参）
{
       ......
}

complex operator + (complex c2); //+重载为成员函数
complex operator - (complex c2); //-重载为成员函数
complex complex::operator +(complex c2) //重载函数实现
{
	complex c;
	c.real=c2.real+real;
	c.imag=c2.imag+imag;
	return complex(c.real,c.imag);
}
complex c1(5,4),c2(2,10),c3;  //声明复数类的对象
c3=c1-c2;	//使用重载运算符完成复数减法
```


```c
Clock&  operator ++();  //前置单目运算符重载
Clock operator ++(int);  //后置单目运算符重载
```

- 非成员运算符函数

```c
friend complex operator + (complex c1,complex c2);	
//运算符+重载为友元函数
friend complex operator - (complex c1,complex c2);
complex operator +(complex c1,complex c2)	
//运算符重载友元函数实现
{	  return      complex(c2.real+c1.real, c2.imag+c1.imag);
}
complex operator -(complex c1,complex c2)	
//运算符重载友元函数实现
{	return       complex(c1.real-c2.real, c1.imag-c2.imag);
}

```
## 虚函数

虚函数是动态绑定的基础

virtual 只用来说明类声明中的原型，不能用在函数实现时。

**本质：不是重载声明而是覆盖。**

调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。

## 何时需要虚析构函数？

当你可能通过基类指针删除派生类对象时

如果你打算允许其他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），并且被析构的对象是有重要的析构函数的派生类的对象，就需要让基类的析构函数成为虚拟的。

## 抽象类

带有纯虚函数的类称为抽象类:


```c
class  类名
 {
     virtual 类型 函数名(参数表)=0; 
     //纯虚函数
     ...
}
```

作用

抽象类为抽象和设计的目的而声明，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。
对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。

注意
抽象类只能作为基类来使用。
不能声明抽象类的对象。
构造函数不能是虚函数，析构函数可以是虚函数



运算符重载
虚函数
纯虚函数
抽象类

虚函数:

本质：不是重载声明而是覆盖。
调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。

抽象类

带有纯虚函数的类称为抽象类:

# 第九章 群体类和群体数据的组织

1. 模板
1. 群体类
1. 群体数据的组织

- 模板

函数模板

类模板




##  函数模板

函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。
声明方法：

- 当类型参数的含义确定后，编译器将以函数模板为样板，生成一个函数

```c
template <typename  标识符> 
函数声明

template<typename T>
T abs(T x)
{    return x<0?-x:x;    }

```

## 类模板

使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值，能取任意类型（包括基本类型的和用户自定义类型）。

```c
template <模板参数表>
class 类名
{类成员声明}
如果需要在类模板以外定义其成员函数，则要采用以下的形式：
template <模板参数表>
类型名 类名<T>::函数名（参数表）
```

```c
template <class T>  
   //类模板：实现对任意类型数据进行存取
class Store
{ private:
   T item; //用于存放任意类型的数据
   int haveValue;//用于标记item是否已被存入内容
  public:
   Store(void); //默认形式（无形参）的构造函数
   GetElem(void);  //提取数据函数
   void PutElem(T x);//存入数据函数
};
// 默认形式构造函数的实现
template <class T>
Store<T>::Store(void): haveValue(0) {}
```



template <模板参数表>
class 类名
{类成员声明}

template <class T>  
   //类模板：实现对任意类型数据进行存取
class Store
{ private:
   T item; //用于存放任意类型的数据
   int haveValue;//用于标记item是否已被存入内容
  public:
   Store(void); //默认形式（无形参）的构造函数
   GetElem(void);  //提取数据函数
   void PutElem(T x);//存入数据函数
};


## 链表的基本操作

1. 生成结点
1. 插入结点
1. 查找结点
1. 删除结点
1. 遍历链表
1. 清空链表

# 第十章 C++标准模板库

1. 泛型程序设计
1. 与标准模板库有关的概念和术语
1. C++标准模板库中的容器
1. 迭代器
1. 标准C++库中的算法
1. 函数对象 

STL是泛型程序设计的一个范例 

1. 容器(container)

1. 迭代器(iterator)

1. 算法（algorithms）

1. 函数对象（function object）

```c
通用容器运算符
==，!=，>，>=，<，<=，=
方法（函数）
迭代方法
begin()，end()，rbegin()，rend()
访问方法
size()，max_size()，swap()，empty()
```

##  七种基本容器：

向量（vector）、双端队列（deque）、列表（list）、集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）


## 适配器

三种类型的适配器：
容器适配器
用来扩展7种基本容器，它们和顺序容器相结合构成栈、队列和优先队列容器
迭代器适配器
函数对象适配器。

## 迭代器

迭代器是面向对象版本的指针，它们提供了访问容器、序列中每个元素的方法。


## 顺序容器

插入方法
push_front()，push_back()，insert()，运算符“=”

删除方法
pop() ，erase()，clear()
迭代访问方法
使用迭代器
其他顺序容器访问方法（不修改访问方法）
front()，back()，下标[]运算符


## 顺序容器——向量

```c
#include <vector>	//包含向量容器头文件
vector<int>  A(10);	
A[primecount++] = 2;
```

## 顺序容器——双端队列

```c 
#include <list>
list<int> Link;	
//构造一个列表用于存放整数链表
Link.push_front(item);
list<int>::iterator p=Link.begin(); 
 while(p!=Link.end())//输出各节点数据，直到链表尾
 { cout <<*p << "  ";
   p++;  //使P指向下一个节点
 }

```

## 容器适配器

容器适配器也是类模板，它使用容器存储元素，但提供了比标准容器更严苛的接口。

容器适配器是用来扩展7种基本容器的
栈容器
使用适配器与一种基础容器相结合来实现
例10-4：应用标准库中的deque顺序容器生成一个整数栈stack。
队列容器
使用适配器与一种基础容器相结合来实现的先进先出数据结构。

## 函数对象

一个行为类似函数的对象，它可以没有参数，也可以带有若干参数，其功能是获取一个值，或者改变操作的状态。
任何普通的函数和任何重载了调用运算符operator()的类的对象都满足函数对象的特征

STL中也定义了一些标准的函数对象，如果以功能划分，可以分为算术运算、关系运算、逻辑运算三大类。为了调用这些标准函数对象，需要包含头文件<functional>。


# 第十一章 流类库与输入/输出

1. I/O流的概念
1. 输出流
1. 输入流
1. 输入/输出流



最重要的三个输出流是
ostream
ofstream
ostringstream


ofstream类支持磁盘文件输出
如果在构造函数中指定一个文件名，当构造这个文件时该文件是自动打开的
```c 

ofstream myFile("filename",iosmode);
ofstream myFile; //声明一个静态输出文件流对象
myFile.open("filename",iosmode);    
//打开文件，使流对象与文件建立联系
ofstream* pmyFile = new ofstream;    
//建立一个动态的输出文件流对象
pmyFile->open("filename",iosmode);
 //打开文件，使流对象与文件建立联系
```

## 输入流对象

```c 
ifstream myFile("filename",iosmode);
在调用默认构造函数之后使用open函数来打开文件。
ifstream myFile;//建立一个文件流对象
myFile.open("filename",iosmode);
  //打开文件"filename"
```



ofstream类支持磁盘文件输出

# 第十二章 异常处理

1. 异常处理的基本思想
1. C++异常处理的实现
1. 异常处理中的构造与析构


```c 
try
   复合语句
catch（异常类型声明）
    复合语句
catch（异常类型声明）
    复合语句
    …
```

```c
try
	{ cout<<"5/2="<<Div(5,2)<<endl;
	  cout<<"8/0="<<Div(8,0)<<endl;
	  cout<<"7/1="<<Div(7,1)<<endl;
	}
   catch(int)
	{ cout<<"except of deviding zero.\n"; }
	cout<<"that is ok.\n";
}
```

异常处理中的构造与析构

找到一个匹配的catch异常处理后

1. 初始化参数。
1. 将从对应的try块开始到异常被抛掷处之间构造（且尚未析构）的所有自动对象进行析构。
1. 从最后一个catch处理之后开始恢复执行。


##  面试问题

1. ->  * 区别

对象名.* 类成员指针名
或：

对象指针名—>*类成员指针名


1. malloc/free与new/delete的区别

- 相同点：

都可用于申请动态内存和释放内存

本质区别
malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。

- 不同点：
操作对象有所不同。

malloc与free是C++/C 语言的标准库函数，new/delete 是C++的运算符。对于非内部数据类的对象而言，光用maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。

用法上也有所不同。

函数malloc 的原型如下：
void * malloc(size_t size);
用malloc 申请一块长度为length 的整数类型的内存，程序如下：
int *p = (int *) malloc(sizeof(int) * length);
我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。

1、malloc 返回值的类型是void *，所以在调用malloc 时要显式地进行类型转换，将void * 转换成所需要的指针类型。
2、 malloc 函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。
函数free 的原型如下：

void free( void * memblock );
为什么free 函数不象malloc 函数那样复杂呢？这是因为指针p 的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。如果p 是NULL 指针，那么free
对p 无论操作多少次都不会出问题。如果p 不是NULL 指针，那么free 对p连续操作两次就会导致程序运行错误。


1、new自动计算需要分配的空间，而malloc需要手工计算字节数
2、new是类型安全的，而malloc不是，比如：

```c
int* p = new float[2]; // 编译时指出错误
int* p = malloc(2*sizeof(float)); // 编译时无法指出错误
```

是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：

第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
第三部：对象构造完成后，返回一个指向该对象的指针。
使用delete操作符来释放对象内存时会经历两个步骤：

第一步：调用对象的析构函数。
第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。
总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子：




1. 特征	new/delete	malloc/free
1. 分配内存的位置	自由存储区	堆
1. 内存分配成功的返回值	完整类型指针	void*
1. 内存分配失败的返回值	默认抛出异常	返回NULL
1. 分配内存的大小	由编译器根据类型计算得出	必须显式指定字节数
1. 处理数组	有处理数组的new版本new[]	需要用户计算数组的大小后进行内存分配
1. 已分配内存的扩充	无法直观地处理	使用realloc简单完成
1. 是否相互调用	可以，看具体的operator new/delete实现	不可调用new
1. 分配内存时内存不足	客户能够指定处理函数或重新制定分配器	无法通过用户代码进行处理
1. 函数重载	允许	不允许
1. 构造函数与析构函数	调用	不调用

- 联系

既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。



1. public  protected private 访问区域

[腾讯求职经历(后附大量面试题)](https://www.nowcoder.com/discuss/260)


面试题汇总（干货）
  
  



## C/C++相关

1. 虚析构、模板和宏 

做基类的类的析构函数一般都是虚函数
这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。
当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数


由于宏定义只是用宏名对一个字符串进行简单的替换，因此如果在宏定义命令后加了分号，将会连同分号一起进行置换。



2. 虚函数实现机制 
3.  vector与list的区别，map是如何实现的，查找效率.

数组 队列  

红黑树


4.  extern 关键字有什么用 

定义：外部变量是指在函数或者文件外部定义的全局变量。外部变量定义必须在所有的函数之外，且只能定义一次。

5.. malloc和new的区别，能否malloc(1.2G)
  
## linux以及操作系统相关

1. 内存池实现 
2. 进程间通信机制 
3. Linux ps命令，以及看内存当前使用状态的命令
4. 进程与线程的区别，共享的数据 
5. 进程的内存空间
  
## 算法与数据结构

1. 大整数加、减、乘、除、求模运算实现 
2. 很多整数，找其中出现次数最多的那个数 
3. 单链表翻转（两个指针如何实现）、查找、删除、插入以及双向链表、有序链表合并 
4. 判断一个整数是否是2的整数次幂.(n&(n-1)) 
5.   二分查找（注意边界条件） 
6.   常见排序算法的实现以及稳定性（快排跟归并考的很多） 
7. 字符串翻转（O(n)）、匹配（KMP算法） 
8.   最长递增子序列（nlogn的算法） 
9.   链表判断是否有环，环的入口，两个链表是否相交（快慢指针）。 
10.   指定一个数组，求2个数的和等于指定的和（某一个数），如果是3,4,5，n个等于个的和（某一个数）呢？（可以看作背包问题） 
11. 跳台阶问题
  
## 其他
   
1. 红黑树的性质以及插入和删除 
2. 解析XML文件 
3. 千万级的用户，提供一个服务，该服务有很多模块，现在有一个底层模块需要优化，问怎么实现，在不影响其他服务模块以及用户体验的情况下。（面IEG）
4. 卡特兰数以及公式推导（应多很多） 
5. 未知大小的文件，翻转整个文件 
6. 如果内存中有个cache存储qq号和最近登录时间问怎么样做hit和淘汰 
7. 检测短信敏感词 
8. 大数据问题 
9. C++、java和PHP有什么本质区别


[腾讯一面面经](https://www.nowcoder.com/discuss/11423)


1. 问项目、实习经历（将近50分钟） 
2. 创建一个server有哪些步骤（socket层面）？如果使用IO复用呢？ 
3. select和epoll有什么区别？ 




4. TCP三次握手和四次挥手？为什么要四次挥手？ 
5. linux查看CPU使用情况用什么命令？查看内存呢？

free -m 
6. load average后面三个数分别表示什么？ 
load average: 0.06, 0.60, 0.48
系统负载，即任务队列的平均长度。 三个数值分别为  1分钟、5分钟、15分钟前到现在的平均值。

7. CPU的%sy, %us分别表示什么？什么情况会改变%sy？

Cpu(s):  1.8%us,  5.1%sy, 

Cpu(s): 0.3% us
用户空间占用CPU百分比
1.0% sy
内核空间占用CPU百分比

