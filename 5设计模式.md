# Java设计模式

## 图书

1. 《大话设计模式》（程杰）
1. 《设计模式》（刘伟，清华大学出版社）
1. 强烈推荐《设计模式之禅》

##　看图书

![](https://images-cn.ssl-images-amazon.com/images/I/51xb%2B7p9wTL._SY498_BO1,204,203,200_.jpg)


## 学习[史上最全设计模式导学目录（完整版）](http://blog.csdn.net/lovelion/article/details/17517213)


![](http://i.imgur.com/LlG4WlO.png)

基础知识
 
设计模式概述
从招式与内功谈起——设计模式概述（一）：设计模式从何而来？
从招式与内功谈起——设计模式概述（二）：设计模式是什么？
从招式与内功谈起——设计模式概述（三）：设计模式有什么用？附：个人观点


这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致

1. 单一职责原则  一个类只负责一个功能领域中的相应职责
1. 开闭原则 软件实体应对扩展开放，而对修改关闭(抽象化是开闭原则的关键)
	系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
1. 里氏代换原则 所有引用基类对象的地方能够透明地使用其子类的对象
	在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

	因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

	里氏代换原则是实现开闭原则的重要方式之一。

1. 依赖倒转原则 抽象不应该依赖于细节，细节应该依赖于抽象
	要针对接口编程，而不是针对实现编程。



1. 接口隔离原则 使用多个专门的接口，而不使用单一的总接口
	即客户端不应该依赖那些它不需要的接口。

	在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

1. 合成复用原则 尽量使用对象组合，而不是继承来达到复用的目的
	组合降低耦合度
1. 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用
	迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。


 
# 六个创建型模式
 
在所有的工厂模式中，我们都强调一点：两个类A和B之间的关系应该**仅仅是A创建B或是A使用B，而不能两种关系都有。**

## 简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】

简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。


工厂三兄弟之简单工厂模式（一）：图表库的设计

工厂三兄弟之简单工厂模式（二）：简单工厂模式概述

工厂三兄弟之简单工厂模式（三）：图表库的简单工厂模式解决方案

工厂三兄弟之简单工厂模式（四）：图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结


简单工厂模式的主要优点如下：

(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。


简单工厂模式的主要缺点如下：

(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。

(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

   简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。



##　工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】

工厂三兄弟之工厂方法模式（一）：日志记录器的设计

工厂三兄弟之工厂方法模式（二）：工厂方法模式概述

工厂三兄弟之工厂方法模式（三）：日志记录器的工厂方法模式解决方案，反射与配置文件

工厂三兄弟之工厂方法模式（四）：重载的工厂方法，工厂方法的隐藏，工厂方法模式总结

工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)
，又可称作**虚拟构造器模式**(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式

![](http://img.blog.csdn.net/20130712102729562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 - 工厂方法模式的主要优点如下：
 
 (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
 
 (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。
 
 (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开

 
 - 工厂方法模式的主要缺点如下：
 
 (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
 
 (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实

 

## 抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】

工厂三兄弟之抽象工厂模式（一）：界面皮肤库的初始设计

工厂三兄弟之抽象工厂模式（二）：产品等级结构与产品族

工厂三兄弟之抽象工厂模式（三）：抽象工厂模式概述

工厂三兄弟之抽象工厂模式（四）：界面皮肤库的抽象工厂模式解决方案

工厂三兄弟之抽象工厂模式（五）：“开闭原则”的倾斜性，抽象工厂模式总结

![](http://img.blog.csdn.net/20130713163800203?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。


抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。


在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。


 **抽象工厂模式的主要优点如下：**
 
 (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
 
 (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
 
 (3) 增加新的产品族很方便，无须修改已有系统，符合“开

**抽象工厂模式的主要缺点如下：**

增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，
这显然会带来较大的不便，违背了“开闭原则”。
 


## 单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】

确保对象的唯一性——单例模式 （一）：单例模式的动机，单例模式概述

确保对象的唯一性——单例模式 （二）：负载均衡器的设计与实现

确保对象的唯一性——单例模式 （三）：饿汉式单例与懒汉式单例的讨论

确保对象的唯一性——单例模式 （四）：一种更好的单例实现方法（静态内部类）

确保对象的唯一性——单例模式 （五）：单例模式总结

Windows任务管理器．只能启动一个．

单例模式：


单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，
这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。


```java
class TaskManager
{
     private static TaskManager tm = null;//静态类型的私有成员变量
     private TaskManager() {……} //构造函数改为private，
     public static TaskManager getInstance()//静态方法,创建实例
     {
        if (tm == null)
        {
            tm = new TaskManager();
        }
        return tm;
    }
   ……
}
```


问题,当创建实例慢,多线程中,容易创建多个实例.


### 饿汉式单例与懒汉式单例的讨论

饿汉式单例类是实现起来最简单的单例类
定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象

```java
class EagerSingleton { 
    private static final EagerSingleton instance = new EagerSingleton(); 
    private EagerSingleton() { } 

    public static EagerSingleton getInstance() {
        return instance; 
    }   
}
```


在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，
为了避免多个线程同时调用getInstance()方法，我们可以使用关键字**synchronized，**

**synchronized**加锁.

```java

class LazySingleton { 
    private static LazySingleton instance = null; 

    private LazySingleton() { } 

    synchronized public static LazySingleton getInstance() { 
        if (instance == null) {
            instance = new LazySingleton(); 
        }
        return instance; 
    }
}
```

因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为双重检查锁定(Double-Check Locking)。

**需要在静态成员变量instance之前增加修饰符volatile，**

```java

class LazySingleton { 
    private volatile static LazySingleton instance = null; 

    private LazySingleton() { } 

    public static LazySingleton getInstance() { 
        //第一重判断
        if (instance == null) {
            //锁定代码块
            synchronized (LazySingleton.class) {
                //第二重判断
                if (instance == null) {
                    instance = new LazySingleton(); //创建单例实例
                }
            }
        }
        return instance; 
    }
}
```

饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；
从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。
但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，
因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象
加载时间可能会比较长。

懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个
线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化
很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等
机制进行控制，这将导致系统性能受到一定影响。


### 静态内部类, 一种更好的单例实现方法

该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，

由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。
静态变量初始化一次.

通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，
不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。


```java
//Initialization on Demand Holder
class Singleton {
	private Singleton() {
	}
	
	private static class HolderClass {
            private final static Singleton instance = new Singleton();
	}
	
	public static Singleton getInstance() {
	    return HolderClass.instance;
	}
	
	public static void main(String args[]) {
	    Singleton s1, s2; 
            s1 = Singleton.getInstance();
	    s2 = Singleton.getInstance();
	    System.out.println(s1==s2);
	}
}
```


- 单例模式的主要优点如下：

(1) 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。

(2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。

(3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损


- 单例模式的主要缺点如下：

(1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。

(2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。

(3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象


### 枚举类

关于单例模式的实现有很多种，网上也分析了如今实现单利模式最好用枚举，好处不外乎三点：

1.线程安全 2.不会因为序列化而产生新实例 3.防止反射攻击

```java
public enum Singleton {
    INSTANCE {

        @Override
        protected void read() {
            System.out.println("read");
        }

        @Override
        protected void write() {
            System.out.println("write");
        }

    };
    protected abstract void read();
    protected abstract void write();
}
```


## 原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

对象的克隆——原型模式（一）：大同小异的工作周报，原型模式概述

对象的克隆——原型模式（二）：工作周报的原型模式解决方案

对象的克隆——原型模式（三）：带附件的周报【浅克隆，深克隆】

对象的克隆——原型模式（四）：原型管理器的引入和实现，原型模式总结


可以通过一个原型对象克隆出多个一模一样的对象，该模式称之为原型模式。

**原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式是一种对象创建型模式。**


```java
class ConcretePrototype implements Prototype
{
    private String  attr; //成员属性
    public void  setAttr(String attr)
    {
        this.attr = attr;
    }
    public String  getAttr()
    {
        return this.attr;
    }
    public Prototype  clone() //克隆方法
    {
        Prototype  prototype = new ConcretePrototype(); //创建新对象
        prototype.setAttr(this.attr);
        return prototype;
    }
}
```


在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。
序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。
通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，
因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。
需要注意的是能够实现序列化的对象其类必须实现Serializable接口，
否则无法实现序列化操作。下面我们使用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写入流中，因此两个类均需要实现Serializable接口，其结构如图7-7所示：





## 建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】

复杂对象的组装与创建——建造者模式（一）：游戏角色设计，建造者模式概述

复杂对象的组装与创建——建造者模式（二）：游戏角色设计的建造者模式解决方案

复杂对象的组装与创建——建造者模式（三）：关于Director的进一步讨论，建造者模式总结

 **建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。**

![](http://my.csdn.net/uploads/201204/04/1333532291_9501.gif)


1.  Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。
1. ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
1. Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。
1.  Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。


建造者模式的主要优点如下：

(1) 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

(2) 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”

(3) 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。


建造者模式的主要缺点如下：

(1) 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。

(2) 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。


# 七个结构型模式

 

##　适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】

不兼容结构的协调——适配器模式（一）：没有源码的算法库，适配器模式概述

不兼容结构的协调——适配器模式（二）：没有源码的算法库的适配器模式解决方案

不兼容结构的协调——适配器模式（三）：类适配器，双向适配器

不兼容结构的协调——适配器模式（四）：缺省适配器，适配器模式总结



**适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以
作为类结构型模式，也可以作为对象结构型模式。**

![](http://img.my.csdn.net/uploads/201302/28/1362066399_9469.jpg)


1. Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。
1. Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。
1. Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。


### 类适配器

类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系

### 缺省适配器

缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，
可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽
象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。


##　桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

处理多维度变化——桥接模式（一）：跨平台图像浏览系统

处理多维度变化——桥接模式（二）：桥接模式概述

处理多维度变化——桥接模式（三）：跨平台图像浏览系统的桥接模式解决方案

处理多维度变化——桥接模式（四）：适配器模式与桥接模式的联用，桥接模式总结

**桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。**

![](http://my.csdn.net/uploads/201204/16/1334505919_5277.gif)

1. Abstraction（抽象类）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。
1. RefinedAbstraction（扩充抽象类）：扩充由Abstraction定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。
1. Implementor（实现类接口）：定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在Abstraction中不仅拥有自己的方法，还可以调用到Implementor中定义的方法，使用关联关系来替代继承关系。
1. ConcreteImplementor（具体实现类）：具体实现Implementor接口，在不同的ConcreteImplementor中提供基本操作的不同实现，在程序运行时，ConcreteImplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。

![](http://my.csdn.net/uploads/201204/16/1334505925_6719.gif)


```java


interface Implementor {  
    public void operationImpl();  
}  

abstract class Abstraction {  
    protected Implementor impl; //定义实现类接口对象  
      
    public void setImpl(Implementor impl) {  
        this.impl=impl;  
    }  
      
    public abstract void operation();  //声明抽象业务方法  
} 

class RefinedAbstraction extends Abstraction {  
    public void operation() {  
        //业务代码  
        impl.operationImpl();  //调用实现类的方法  
        //业务代码  
    }  
}  

```




##　组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

树形结构的处理——组合模式（一）：设计杀毒软件的框架结构

树形结构的处理——组合模式（二）：组合模式概述

树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案

树形结构的处理——组合模式（四）：透明组合模式与安全组合模式

树形结构的处理——组合模式（五）：公司组织结构，组合模式总结


使用具有一致性

**组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。
组合模式对单个对象（即叶子对象）和组合对象（即容器对象）
的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。**

![](http://img.my.csdn.net/uploads/201209/07/1347029718_6268.jpg)

客户端针对Component进行编程.
 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，
 而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理


 1. Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
 1. Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
 1. Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，1.     


```java
abstract class Component {  
    public abstract void add(Component c); //增加成员  
    public abstract void remove(Component c); //删除成员  
    public abstract Component getChild(int i); //获取成员  
    public abstract void operation();  //业务方法  
}  

class Leaf extends Component {  
    public void add(Component c) {   
        //异常处理或错误提示   
    }     
          
    public void remove(Component c) {   
        //异常处理或错误提示   
    }  
      
    public Component getChild(int i) {   
        //异常处理或错误提示  
        return null;   
    }  
      
    public void operation() {  
        //叶子构件具体业务方法的实现  
    }   
} 


class Composite extends Component {  
    private ArrayList<Component> list = new ArrayList<Component>();  
      
    public void add(Component c) {  
        list.add(c);  
    }  
      
    public void remove(Component c) {  
        list.remove(c);  
    }  
      
    public Component getChild(int i) {  
        return (Component)list.get(i);  
    }  
      
    public void operation() {  
        //容器构件具体业务方法的实现  
        //递归调用成员构件的业务方法  
        for(Object obj:list) {  
            ((Component)obj).operation();  
        }  
    }     
}  

```

### 透明组合模式与安全组合模式

重复实现抽象方法

解决方案一：将叶子构件的add()、remove()等方法的实现代码移至AbstractFile类中，
由AbstractFile提供统一的默认实现，代码如下所示：

这样就产生了一种不透明的使用方式，即在客户端不能全部针对抽象构件类编程，需要使用具体叶子构件类型来定义叶子对象。

解决方案二：除此之外，还有一种解决方法是在抽象构件AbstractFile中不声明任何用于访问和管
理成员构件的方法，代码如下所示：

(1) 透明组合模式

透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法
包括add()、remove()以及getChild()等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式，虽然上面的解决方案一在客户端可以有不透明的实现方法，但是由于在抽象构件中包含add()、remove()等方法，因此它还是透明组合模式，透明组合模式的完整结构如图11-6所示

(2) 安全组合模式

安全组合模式中，在抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法，这就是解决方案二所采用的实现方式。

- 组合模式的主要优点如下：

(1) 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。

(2) 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。

(3) 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。

(4) 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。



- 组合模式的主要缺点如下：

在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。




##　装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

扩展系统功能——装饰模式（一）：图形界面构件库的设计

扩展系统功能——装饰模式（二）：装饰模式概述

扩展系统功能——装饰模式（三）：图形界面构件库的装饰模式解决方案

扩展系统功能——装饰模式（四）：透明装饰模式与半透明装饰模式，装饰模式注意事项，装饰模式总结

我们也有一种类似新房装修的技术可以对已有对象（新房）的功能进行扩展（装修），
以获得更加符合用户需求的对象，使得对象具有更加强大的功能。这种技术对应于一种被
称之为装饰模式的设计模式

  装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，
  使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，
  在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。


**装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，
装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。**

装饰模式的核心在于抽象装饰类的设计，

![](http://my.csdn.net/uploads/201204/04/1333528185_7832.gif)

1. Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。
1. ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
1. Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。
1. ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。

由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态
地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么
不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。

```java
class Decorator implements Component
{
       private Component component;  //维持一个对抽象构件对象的引用
       public Decorator(Component component)  //注入一个抽象构件类型的对象
       {
              this.component=component;
       }
 
       public void operation()
       {
              component.operation();  //调用原有业务方法
       }
}
```

在Decorator的子类即具体装饰类中将继承operation()方法并根据需要进行扩展，
典型的具体装饰类代码如下

```java
class ConcreteDecorator extends Decorator
{
       public ConcreteDecorator(Component  component)
       {
              super(component);
       }
 
       public void operation()
       {
              super.operation();  //调用原有业务方法
              addedBehavior();  //调用新增业务方法
       }
 
     //新增业务方法
       public  void addedBehavior()
       {    
         ……
}
}
```

![](http://my.csdn.net/uploads/201204/04/1333528353_8435.gif)



```java
//抽象界面构件类：抽象构件类，为了突出与模式相关的核心代码，对原有控件代码进行了大量的简化
abstract class Component
{
       public  abstract void display();
}
 
//窗体类：具体构件类
class Window extends Component
{
       public  void display()
       {
              System.out.println("显示窗体！");
       }
}
 
//文本框类：具体构件类
class TextBox extends Component
{
       public  void display()
       {
              System.out.println("显示文本框！");
       }
}
 
//列表框类：具体构件类
class ListBox extends Component
{
       public  void display()
       {
              System.out.println("显示列表框！");
       }
}
 
//构件装饰类：抽象装饰类
class ComponentDecorator extends Component
{
       private Component component;  //维持对抽象构件类型对象的引用
 
       public ComponentDecorator(Component  component)  //注入抽象构件类型的对象
       {
              this.component = component;
       }
 
       public void display()
       {
              component.display();
       }
}
 
//滚动条装饰类：具体装饰类
class ScrollBarDecorator extends  ComponentDecorator
{
       public ScrollBarDecorator(Component  component)
       {
              super(component);
       }
 
       public void display()
       {
              this.setScrollBar();
              super.display();
       }
 
       public  void setScrollBar()
       {
              System.out.println("为构件增加滚动条！");
       }
}
 
//黑色边框装饰类：具体装饰类
class BlackBorderDecorator extends  ComponentDecorator
{
       public BlackBorderDecorator(Component  component)
       {
              super(component);
       }
 
       public void display()
       {
              this.setBlackBorder();
              super.display();
       }
 
       public  void setBlackBorder()
       {
              System.out.println("为构件增加黑色边框！");
       }
}
```


      编写如下客户端测试代码：
```java
class Client
{
       public  static void main(String args[])
       {
              Component component,componentSB;  //使用抽象构件定义
              component = new Window(); //定义具体构件
              componentSB = new  ScrollBarDecorator(component); //定义装饰后的构件
              componentSB.display();
       }
}
```

在客户端代码中，我们先定义了一个Window类型的具体构件对象component，
然后将component作为构造函数的参数注入到具体装饰类ScrollBarDecorator中，
得到一个装饰之后对象componentSB，再调用componentSB的display()方法后将得到一个
有滚动条的窗体。如果我们希望得到一个既有滚动条又有黑色边框的窗体
，不需要对原有类库进行任何修改，只需将客户端代码修改为如下所示：

```java
class Client
{
       public  static void main(String args[])
       {
              Component  component,componentSB,componentBB; 
              //全部使用抽象构件定义
              component = new Window();
              componentSB = new  ScrollBarDecorator(component);
              componentBB = new  BlackBorderDecorator(componentSB); 
              //将装饰了一次之后的对象继续注入到另一个装饰类中，进行第二次装饰
              componentBB.display();
       }
}
```

如果需要在原有系统中增加一个新的具体构件类或者新的具体装饰类，
无须修改现有类库代码，只需将它们分别作为抽象构件类或者抽象装饰类的子类即可。
与图12-2所示的继承结构相比，使用装饰模式之后将大大减少了子类的个数，让系统
扩展起来更加方便，而且更容易维护，是取代继承复用的有效方式之一。


### 透明装饰模式与半透明装饰模式


在实际使用过程中，由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，
这种装饰模式被称为半透明(Semi-transparent)装饰模式，而标准的装饰模式是透明(Transparent)
装饰模式。下面我们对这两种装饰模式进行较为详细的介绍：

- 半透明装饰模式

具体装饰类单独增加新方法,新增行为可能需要单独调用,称为半透明装饰模式.

- 透明装饰模式中，要求客户端完全针对抽象编程

透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别
此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象



- 装饰模式的主要优点如下：

(1) 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。

(2) 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。

(3) 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。

(4) 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。



- 装饰模式的主要缺点如下：

(1) 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。

(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。





##　外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】

深入浅出外观模式（一）：外观模式概述，外观模式结构与实现

深入浅出外观模式（二）：外观模式应用实例（文件加密模块）

深入浅出外观模式（三）：抽象外观类，外观模式效果与适用场景

它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提
供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。

![](http://img.my.csdn.net/uploads/201212/04/1354636729_2852.jpg)

**外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。**

![](http://img.my.csdn.net/uploads/201212/04/1354636733_5965.jpg)


(1) Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。

(2) SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客





```java
class SubSystemA  
{  
    public void MethodA()  
    {  
        //业务实现代码  
    }  
}  
  
class SubSystemB  
{  
    public void MethodB()  
    {  
        //业务实现代码  
     }  
}  
  
class SubSystemC  
{  
    public void MethodC()  
    {  
        //业务实现代码  
    }  
}  
```

-外观类

```java
class Facade  
{  
    private SubSystemA obj1 = new SubSystemA();  
    private SubSystemB obj2 = new SubSystemB();  
    private SubSystemC obj3 = new SubSystemC();  
  
    public void Method()  
    {  
        obj1.MethodA();  
        obj2.MethodB();  
        obj3.MethodC();  
    }  
}  
```

- 客户端

客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。


```java
class Program  
{  
    static void Main(string[] args)  
    {  
        Facade facade = new Facade();  
        facade.Method();  
    }  
}  
```

### 抽象外观类

如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，
这将违背开闭原则，因此可以通过引入抽象外观类来对系统进行改进


对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，
由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何
源代码并更换外观类的目的。


- 外观模式的主要优点如下：

(1) 它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。


(2) 它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。


(3) 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到


- 外观模式的主要缺点如下：
 
 (1) 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活 性。
 
 (2) 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了







##　享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】

实现对象的复用——享元模式（一）：围棋棋子的设计，享元模式概述（上）

实现对象的复用——享元模式（二）：享元模式概述（下）

实现对象的复用——享元模式（三）：围棋棋子的享元模式解决方案

实现对象的复用——享元模式（四）：带外部状态的围棋棋子解决方案

实现对象的复用——享元模式（五）：单纯享元模式和复合享元模式，关于享元模式的几点补充，享元模式总结

共享相似对象


**享元模式(Flyweight Pattern)：运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，它是一种对象结构型模式。**



享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态(Intrinsic State)和外部状态(Extrinsic State)。下面将对享元的内部状态和外部状态进行简单的介绍：

(1)  内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。如字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”。

(2)  外部状态是随环境改变而改变的、不可以共享的状态。




##　代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

代理模式（一）：代理模式概述，代理模式结构与实现

代理模式（二）：代理模式应用实例（收费商务信息查询系统）

代理模式（三）：远程代理，虚拟代理，缓冲代理

代理模式（四）：代理模式效果与适用场景

代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过
一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相
同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理
、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。

常见的代理形式包括

远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，

**代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。**

![](http://img.my.csdn.net/uploads/201211/26/1353942400_6301.jpg)


   (1) Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
   
   (2) Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。
    
   (3) RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。


```java
abstract class Subject  
{  
    public abstract void Request();  
}  

class RealSubject : Subject  
{  
    public override void Request()  
    {  
        //业务方法具体实现代码  
    }  
} 

class Proxy : Subject  
{  
    private RealSubject realSubject = new RealSubject(); //维持一个对真实主题对象的引用  
  
    public void PreRequest()   
    {  
        …...  
    }  
  
    public override void Request()   
    {  
        PreRequest();  
        realSubject.Request(); //调用真实主题对象的方法  
         PostRequest();  
    }  
  
    public void PostRequest()   
    {  
        ……  
    }  
}
```



(1) 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。

远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信


(2) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。

由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象

当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。

虚拟代理都是用一个“虚假”的代理对象来代表真实对象


(3) 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
    
(4) 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。
    
(5) 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。


- 共同优点

(1) 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。

(2) 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。

- 模式缺点

(1) 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。
 
(2) 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。
 


十一个行为型模式

 

##　职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】

请求的链式处理——职责链模式（一）：采购单的分级审批

请求的链式处理——职责链模式（二）：职责链模式概述

请求的链式处理——职责链模式（三）：采购单分级审批的职责链模式解决方案

请求的链式处理——职责链模式（四）：纯与不纯的职责链模式，职责链模式总结


![](http://my.csdn.net/uploads/201204/02/1333307283_7751.gif)

采购单的分级审批,大量的if判断

**职责链模式(Chain of Responsibility  Pattern)：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。**'

![](http://my.csdn.net/uploads/201204/02/1333307613_2407.gif)

1. Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为其对下家的引用。通过该引用，处理者可以连成一条链。
1. ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。
1. 在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。

Handler（抽象处理者

```java
abstract class Handler {  
    //维持对下家的引用  
protected Handler successor;  
      
    public void setSuccessor(Handler successor) {  
        this.successor=successor;  
    }  
      
    public abstract void handleRequest(String request);  
}  
```

ConcreteHandler（具体处理者）

```java
class ConcreteHandler extends Handler {  
    public void handleRequest(String request) {  
        if (请求满足条件) {  
            //处理请求  
        }  
        else {  
            this.successor.handleRequest(request);  //转发请求  
        }  
    }  
}  
```



```java

```



##　命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

请求发送者与接收者解耦——命令模式（一）：自定义功能键，命令模式概述

请求发送者与接收者解耦——命令模式（二）：自定义功能键的命令模式解决方案

请求发送者与接收者解耦——命令模式（三）：命令队列的实现

请求发送者与接收者解耦——命令模式（四）：撤销操作的简单实现

请求发送者与接收者解耦——命令模式（五）：请求日志

请求发送者与接收者解耦——命令模式（六）：宏命令，命令模式总结



##　解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】

自定义语言的实现——解释器模式（一）：机器人控制程序

自定义语言的实现——解释器模式（二）：文法规则和抽象语法树

自定义语言的实现——解释器模式（三）：解释器模式概述

自定义语言的实现——解释器模式（四）：机器人控制程序的解释器模式解决方案

自定义语言的实现——解释器模式（五）：再谈Context的作用

自定义语言的实现——解释器模式（六）：解释器模式总结



##　迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】

遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历

遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述

遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案

遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器

遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用

遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结


访问一个聚合对象中的元素但又不需要暴露它的内部结构。本章我们将要学习的迭代器模式

将聚合类中负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，
无须暴露聚合类的内部属性即可对其进行操作，

**迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，
其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。**

![](http://img.blog.csdn.net/20130815225537578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

代器模式结构图中包含如下几个角色：

1. Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的first()方法，用于访问下一个元素的next()方法，用于判断是否还有下一个元素的hasNext()方法，用于获取当前元素的currentItem()方法等，在具体迭代器中将实现这些方法。
1. ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。
1. Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个createIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
1. ConcreteAggregate（具体聚合类）：它实现了在抽象聚合类中声明的createIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器ConcreteIterator实

-抽象迭代器

```java
interface Iterator {  
    public void first(); //将游标指向第一个元素  
    public void next(); //将游标指向下一个元素  
    public boolean hasNext(); //判断是否存在下一个元素  
    public Object currentItem(); //获取游标指向的当前元素  
} 
```
- 具体迭代器


```java
class ConcreteIterator implements Iterator {  
    private ConcreteAggregate objects; //维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据  
    private int cursor; //定义一个游标，用于记录当前访问位置  
    public ConcreteIterator(ConcreteAggregate objects) {  
        this.objects=objects;  
    }  
  
    public void first() {  ......  }  
          
    public void next() {  ......  }  
  
    public boolean hasNext() {  ......  }  
      
    public Object currentItem() {  ......  }  
}  
```

- 聚合类

```java
interface Aggregate {  
    Iterator createIterator();  
}  
```

- 具体聚合类

```java
 class ConcreteAggregate implements Aggregate {    
    ......    
    public Iterator createIterator() {  
    return new ConcreteIterator(this);  
    }  
    ......  
}  
```

### 使用内部类实现迭代器

能够让迭代器可以访问到聚合对象中的数据，我们还可以将迭代器类设计为聚合类的内部类，
JDK中的迭代器类就是通过这种方法来实现的，如下AbstractList类代码片段所示：


```java
 package java.util;  
……  
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {  
    ......  
    private class Itr implements Iterator<E> {  
        int cursor = 0;  
        ......  
}  
……  
}  
```

### JDK内置迭代器




- 迭代器模式的主要优点如下：

(1) 它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。

(2) 迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。

(3) 在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原



- 迭代器模式的主要缺点如下：

(1) 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

(2) 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如JDK内置迭代器Iterator就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类ListIterator等来实现，而ListIterator迭代器无法用于操作Set类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。





##　中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】

协调多个对象之间的交互——中介者模式（一）：客户信息管理窗口的初始设计

协调多个对象之间的交互——中介者模式（二）：中介者模式概述

协调多个对象之间的交互——中介者模式（三）：客户信息管理窗口的中介者模式解决方案

协调多个对象之间的交互——中介者模式（四）：中介者与同事类的扩展

协调多个对象之间的交互——中介者模式（五）：中介者模式总结



##　备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】

撤销功能的实现——备忘录模式（一）：可悔棋的中国象棋

撤销功能的实现——备忘录模式（二）：备忘录模式概述

撤销功能的实现——备忘录模式（三）：中国象棋的备忘录模式解决方案

撤销功能的实现——备忘录模式（四）：实现多次撤销

撤销功能的实现——备忘录模式（五）：再谈备忘录的封装，备忘录模式总结



##　观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】

对象间的联动——观察者模式（一）：多人联机对战游戏的设计

对象间的联动——观察者模式（二）：观察者模式概述

对象间的联动——观察者模式（三）：多人联机对战游戏的观察者模式解决方案

对象间的联动——观察者模式（四）：JDK对观察者模式的支持

对象间的联动——观察者模式（五）：观察者模式与Java事件处理

对象间的联动——观察者模式（六）：观察者模式与MVC，观察者模式总结

观察者模式是设计模式中的“超级模式”

“红灯停，绿灯行”，在日常生活中，交通信号灯装点着我们的城市，指挥着日益拥挤的城市交通。
当红灯亮起，来往的汽车将停止；而绿灯亮起，汽车可以继续前行。在这个过程中，交通信号灯
是汽车（更准确地说应该是汽车驾驶员）的观察目标，而汽车
是观察者。随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。

**观察者模式(Observer Pattern)：定义对象之间的一种一对多依赖关系，使得每当一个对象状态
发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式的别名包括发布-订阅
（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）
模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。**

![](http://my.csdn.net/uploads/201207/05/1341501815_4830.jpg)

1.  Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。
1.  ConcreteSubject（具体目标）：具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。
1.  Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者。
1.  ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的update()方法。通常在实现时，可以调用具体目标类的attach()方法将自己添加到目标类的集合中或通过detach()方法将自己从目标类的集合中删除。

一个目标可以有任意数目的与之相依赖的观察者,一旦观察目标的状态发生改变，所有的观察者都将得到通知。

一个抽象目标Subject

```java

import java.util.*;
abstract class Subject {
    //定义一个观察者集合用于存储所有观察者对象
protected ArrayList observers<Observer> = new ArrayList();

//注册方法，用于向观察者集合中增加一个观察者
	public void attach(Observer observer) {
    observers.add(observer);
}

    //注销方法，用于在观察者集合中删除一个观察者
	public void detach(Observer observer) {
    observers.remove(observer);
}

    //声明抽象通知方法
	public abstract void notify();
}
```

具体目标类ConcreteSubject是实现了抽象目标类Subject的一个具体子类，其典型代码如下所示

```java
class ConcreteSubject extends Subject {  
    //实现通知方法  
    public void notify() {  
        //遍历观察者集合，调用每一个观察者的响应方法  
        for(Object obs:observers) {  
            ((Observer)obs).update();  
        }  
    }     
} 
```

抽象观察者角色一般定义为一个接口，通常只声明一个update()方法

```java
interface Observer {  
    //声明响应方法  
    public void update();  
}  
```
在具体观察者ConcreteObserver中实现了update()方法，其典型代码如下所示：

```java
class ConcreteObserver implements Observer {  
    //实现响应方法  
    public void update() {  
        //具体响应代码  
    }  
}  
```

 ### JDK对观察者模式的支持

 观察者模式在Java语言中的地位非常重要。在JDK的java.util包中，提供了Observable类以及
 Observer接口，它们构成了JDK对观察者模式的支持。如图22-5所示

![](http://my.csdn.net/uploads/201207/06/1341504430_1842.jpg)

### 观察者模式与Java事件处理

事件处理模型采用基于观察者模式的委派事件模型(DelegationEvent Model, DEM)，
即一个Java组件所引发的事件并不由引发事件的对象自己来负责处理，而是委派给独立
的事件处理对象负责。

在Java事件处理中，通常使用的是一对一的观察者模式，而不是一对多的观察者模式，

### 观察者模式与MVC

在当前流行的MVC(Model-View-Controller)架构中也应用了观察者模式，MVC是一种架构模式，
它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。其中模型可对应于观察
者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数
据发生改变时，视图层将自动改变其显示内容。如图22-7所示：

![](http://my.csdn.net/uploads/201207/06/1341505104_3429.jpg)



观察者模式的主要优点如下：

(1) 观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。

(2) 观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。

(3) 观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。

(4) 观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标


观察者模式的主要缺点如下：

(1) 如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。

(2) 如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。

(3) 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。



##　状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计

处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述

处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案

处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现

处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换

处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结



##　策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】

算法的封装与切换——策略模式（一）：电影票打折方案

算法的封装与切换——策略模式（二）：策略模式概述

算法的封装与切换——策略模式（三）：电影票打折方案的策略模式解决方案

算法的封装与切换——策略模式（四）：策略模式的两个典型应用，策略模式总结


实现某一个功能有多条途径，每一条途径对应一种算法，此时我们可以使用一种设计模式
来实现灵活地选择解决途径，也能够方便地增加新的解决途径。本章我们将介绍一种为了适
应算法灵活性而产生的设计模式——策略模式。

策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开

**策略模式(Strategy Pattern)：定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。策略模式是一种对象行为型模式。**

![](http://my.csdn.net/uploads/201208/01/1343811032_3729.jpg)

在策略模式结构图中包含如下几个角色：

1. Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。
1. Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。
1. ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。



- 抽象策略类

```java
 abstract class AbstractStrategy {  
    public abstract void algorithm(); //声明抽象算法  
}  
```

- 具体算法

```java
class ConcreteStrategyA extends AbstractStrategy {  
    //算法的具体实现  
    public void algorithm() {  
       //算法A  
    } 
```

- Context 与抽象策略类之间建立一个关联关系


```java
 class Context {  
private AbstractStrategy strategy; //维持一个对抽象策略类的引用  
  
    public void setStrategy(AbstractStrategy strategy) {  
        this.strategy= strategy;  
    }  
  
    //调用策略类中的算法  
    public void algorithm() {  
        strategy.algorithm();  
    }  
} 
```


- 策略模式的主要优点如下：

(1) 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。

(2) 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族，恰当使用继承可以把公共的代码移到抽象策略类中，从而避免重复的代码。

(3) 策略模式提供了一种可以替换继承关系的办法。如果不使用策略模式，那么使用算法的环境类就可能会有一些子类，每一个子类提供一种不同的算法。但是，这样一来算法的使用就和算法本身混在一起，不符合“单一职责原则”，决定使用哪一种算法的逻辑和该算法本身混合在一起，从而不可能再独立演化；而且使用继承无法实现算法或行为在程序运行时的动态切换。

(4) 使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。

(5) 策略模式提供了一种算法的复用机制，由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。


- 策略模式的主要缺点如下：

(1) 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。

(2) 策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。

(3) 无法同时在客户端使用多个策略类，也就是说，在使用策略模式时，客户端每次只能使用一个策略类，不支持使用一个策略类完成部分功能后再使用另一个策略类来完成剩余功能的情况


##　模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】

模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现

模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块）

模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景



##　访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】

操作复杂对象结构——访问者模式（一）：OA系统中员工数据汇总

操作复杂对象结构——访问者模式（二）：访问者模式概述

操作复杂对象结构——访问者模式（三）：OA系统中员工数据汇总的访问者模式解决方案

操作复杂对象结构——访问者模式（四）：访问者模式与组合模式联用，访问者模式总结



设计模式趣味学习（复习）



设计模式与足球（一）：创建型模式

设计模式与足球（二）：结构型模式

设计模式与足球（三）：行为型模式（上）

设计模式与足球（四）：行为型模式（下）



设计模式综合应用实例



多人联机射击游戏

多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式

多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式



数据库同步系统

设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式

设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式

设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式

##  [GitBook 图书 ](https://gof.quanke.name/)

## [http://www.runoob.com/ 设计模式](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)


