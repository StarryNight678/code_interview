# Java设计模式

## 图书

1. 《大话设计模式》（程杰）
1. 《设计模式》（刘伟，清华大学出版社）
1. 强烈推荐《设计模式之禅》

##　看图书

![](https://images-cn.ssl-images-amazon.com/images/I/51xb%2B7p9wTL._SY498_BO1,204,203,200_.jpg)


## 学习[史上最全设计模式导学目录（完整版）](http://blog.csdn.net/lovelion/article/details/17517213)

基础知识
 
设计模式概述
从招式与内功谈起——设计模式概述（一）：设计模式从何而来？
从招式与内功谈起——设计模式概述（二）：设计模式是什么？
从招式与内功谈起——设计模式概述（三）：设计模式有什么用？附：个人观点


这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致

1. 单一职责原则  一个类只负责一个功能领域中的相应职责
1. 开闭原则 软件实体应对扩展开放，而对修改关闭(抽象化是开闭原则的关键)
	系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
1. 里氏代换原则 所有引用基类对象的地方能够透明地使用其子类的对象
	在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

	因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

	里氏代换原则是实现开闭原则的重要方式之一。

1. 依赖倒转原则 抽象不应该依赖于细节，细节应该依赖于抽象
	要针对接口编程，而不是针对实现编程。



1. 接口隔离原则 使用多个专门的接口，而不使用单一的总接口
	即客户端不应该依赖那些它不需要的接口。

	在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

1. 合成复用原则 尽量使用对象组合，而不是继承来达到复用的目的
	组合降低耦合度
1. 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用
	迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。


 
# 六个创建型模式
 
在所有的工厂模式中，我们都强调一点：两个类A和B之间的关系应该**仅仅是A创建B或是A使用B，而不能两种关系都有。**

## 简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】

简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。


工厂三兄弟之简单工厂模式（一）：图表库的设计

工厂三兄弟之简单工厂模式（二）：简单工厂模式概述

工厂三兄弟之简单工厂模式（三）：图表库的简单工厂模式解决方案

工厂三兄弟之简单工厂模式（四）：图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结


简单工厂模式的主要优点如下：

(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。


简单工厂模式的主要缺点如下：

(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。

(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

   简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。



##　工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】

工厂三兄弟之工厂方法模式（一）：日志记录器的设计

工厂三兄弟之工厂方法模式（二）：工厂方法模式概述

工厂三兄弟之工厂方法模式（三）：日志记录器的工厂方法模式解决方案，反射与配置文件

工厂三兄弟之工厂方法模式（四）：重载的工厂方法，工厂方法的隐藏，工厂方法模式总结

工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)
，又可称作**虚拟构造器模式**(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式

![](http://img.blog.csdn.net/20130712102729562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 - 工厂方法模式的主要优点如下：
 
 (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
 
 (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。
 
 (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开

 
 - 工厂方法模式的主要缺点如下：
 
 (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
 
 (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实

 

## 抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】

工厂三兄弟之抽象工厂模式（一）：界面皮肤库的初始设计

工厂三兄弟之抽象工厂模式（二）：产品等级结构与产品族

工厂三兄弟之抽象工厂模式（三）：抽象工厂模式概述

工厂三兄弟之抽象工厂模式（四）：界面皮肤库的抽象工厂模式解决方案

工厂三兄弟之抽象工厂模式（五）：“开闭原则”的倾斜性，抽象工厂模式总结

将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。


抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。


在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。


 **抽象工厂模式的主要优点如下：**
 
 (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
 
 (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
 
 (3) 增加新的产品族很方便，无须修改已有系统，符合“开

**抽象工厂模式的主要缺点如下：**

增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，
这显然会带来较大的不便，违背了“开闭原则”。
 


## 单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】

确保对象的唯一性——单例模式 （一）：单例模式的动机，单例模式概述

确保对象的唯一性——单例模式 （二）：负载均衡器的设计与实现

确保对象的唯一性——单例模式 （三）：饿汉式单例与懒汉式单例的讨论

确保对象的唯一性——单例模式 （四）：一种更好的单例实现方法（静态内部类）

确保对象的唯一性——单例模式 （五）：单例模式总结

Windows任务管理器．只能启动一个．

单例模式：


单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，
这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。


```java
class TaskManager
{
     private static TaskManager tm = null;//静态类型的私有成员变量
     private TaskManager() {……} //构造函数改为private，
     public static TaskManager getInstance()//静态方法,创建实例
     {
        if (tm == null)
        {
            tm = new TaskManager();
        }
        return tm;
    }
   ……
}
```


**饿汉式单例与懒汉式单例的讨论**




## 原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

对象的克隆——原型模式（一）：大同小异的工作周报，原型模式概述

对象的克隆——原型模式（二）：工作周报的原型模式解决方案

对象的克隆——原型模式（三）：带附件的周报【浅克隆，深克隆】

对象的克隆——原型模式（四）：原型管理器的引入和实现，原型模式总结

 

## 建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】

复杂对象的组装与创建——建造者模式（一）：游戏角色设计，建造者模式概述

复杂对象的组装与创建——建造者模式（二）：游戏角色设计的建造者模式解决方案

复杂对象的组装与创建——建造者模式（三）：关于Director的进一步讨论，建造者模式总结

 

# 七个结构型模式

 

适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】

不兼容结构的协调——适配器模式（一）：没有源码的算法库，适配器模式概述

不兼容结构的协调——适配器模式（二）：没有源码的算法库的适配器模式解决方案

不兼容结构的协调——适配器模式（三）：类适配器，双向适配器

不兼容结构的协调——适配器模式（四）：缺省适配器，适配器模式总结



桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

处理多维度变化——桥接模式（一）：跨平台图像浏览系统

处理多维度变化——桥接模式（二）：桥接模式概述

处理多维度变化——桥接模式（三）：跨平台图像浏览系统的桥接模式解决方案

处理多维度变化——桥接模式（四）：适配器模式与桥接模式的联用，桥接模式总结



组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

树形结构的处理——组合模式（一）：设计杀毒软件的框架结构

树形结构的处理——组合模式（二）：组合模式概述

树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案

树形结构的处理——组合模式（四）：透明组合模式与安全组合模式

树形结构的处理——组合模式（五）：公司组织结构，组合模式总结



装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

扩展系统功能——装饰模式（一）：图形界面构件库的设计

扩展系统功能——装饰模式（二）：装饰模式概述

扩展系统功能——装饰模式（三）：图形界面构件库的装饰模式解决方案

扩展系统功能——装饰模式（四）：透明装饰模式与半透明装饰模式，装饰模式注意事项，装饰模式总结



外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】

深入浅出外观模式（一）：外观模式概述，外观模式结构与实现

深入浅出外观模式（二）：外观模式应用实例（文件加密模块）

深入浅出外观模式（三）：抽象外观类，外观模式效果与适用场景



享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】

实现对象的复用——享元模式（一）：围棋棋子的设计，享元模式概述（上）

实现对象的复用——享元模式（二）：享元模式概述（下）

实现对象的复用——享元模式（三）：围棋棋子的享元模式解决方案

实现对象的复用——享元模式（四）：带外部状态的围棋棋子解决方案

实现对象的复用——享元模式（五）：单纯享元模式和复合享元模式，关于享元模式的几点补充，享元模式总结



代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

代理模式（一）：代理模式概述，代理模式结构与实现

代理模式（二）：代理模式应用实例（收费商务信息查询系统）

代理模式（三）：远程代理，虚拟代理，缓冲代理

代理模式（四）：代理模式效果与适用场景



十一个行为型模式

 

职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】

请求的链式处理——职责链模式（一）：采购单的分级审批

请求的链式处理——职责链模式（二）：职责链模式概述

请求的链式处理——职责链模式（三）：采购单分级审批的职责链模式解决方案

请求的链式处理——职责链模式（四）：纯与不纯的职责链模式，职责链模式总结



命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

请求发送者与接收者解耦——命令模式（一）：自定义功能键，命令模式概述

请求发送者与接收者解耦——命令模式（二）：自定义功能键的命令模式解决方案

请求发送者与接收者解耦——命令模式（三）：命令队列的实现

请求发送者与接收者解耦——命令模式（四）：撤销操作的简单实现

请求发送者与接收者解耦——命令模式（五）：请求日志

请求发送者与接收者解耦——命令模式（六）：宏命令，命令模式总结



解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】

自定义语言的实现——解释器模式（一）：机器人控制程序

自定义语言的实现——解释器模式（二）：文法规则和抽象语法树

自定义语言的实现——解释器模式（三）：解释器模式概述

自定义语言的实现——解释器模式（四）：机器人控制程序的解释器模式解决方案

自定义语言的实现——解释器模式（五）：再谈Context的作用

自定义语言的实现——解释器模式（六）：解释器模式总结



迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】

遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历

遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述

遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案

遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器

遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用

遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结



中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】

协调多个对象之间的交互——中介者模式（一）：客户信息管理窗口的初始设计

协调多个对象之间的交互——中介者模式（二）：中介者模式概述

协调多个对象之间的交互——中介者模式（三）：客户信息管理窗口的中介者模式解决方案

协调多个对象之间的交互——中介者模式（四）：中介者与同事类的扩展

协调多个对象之间的交互——中介者模式（五）：中介者模式总结



备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】

撤销功能的实现——备忘录模式（一）：可悔棋的中国象棋

撤销功能的实现——备忘录模式（二）：备忘录模式概述

撤销功能的实现——备忘录模式（三）：中国象棋的备忘录模式解决方案

撤销功能的实现——备忘录模式（四）：实现多次撤销

撤销功能的实现——备忘录模式（五）：再谈备忘录的封装，备忘录模式总结



观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】

对象间的联动——观察者模式（一）：多人联机对战游戏的设计

对象间的联动——观察者模式（二）：观察者模式概述

对象间的联动——观察者模式（三）：多人联机对战游戏的观察者模式解决方案

对象间的联动——观察者模式（四）：JDK对观察者模式的支持

对象间的联动——观察者模式（五）：观察者模式与Java事件处理

对象间的联动——观察者模式（六）：观察者模式与MVC，观察者模式总结



状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计

处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述

处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案

处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现

处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换

处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结



策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】

算法的封装与切换——策略模式（一）：电影票打折方案

算法的封装与切换——策略模式（二）：策略模式概述

算法的封装与切换——策略模式（三）：电影票打折方案的策略模式解决方案

算法的封装与切换——策略模式（四）：策略模式的两个典型应用，策略模式总结



模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】

模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现

模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块）

模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景



访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】

操作复杂对象结构——访问者模式（一）：OA系统中员工数据汇总

操作复杂对象结构——访问者模式（二）：访问者模式概述

操作复杂对象结构——访问者模式（三）：OA系统中员工数据汇总的访问者模式解决方案

操作复杂对象结构——访问者模式（四）：访问者模式与组合模式联用，访问者模式总结



设计模式趣味学习（复习）



设计模式与足球（一）：创建型模式

设计模式与足球（二）：结构型模式

设计模式与足球（三）：行为型模式（上）

设计模式与足球（四）：行为型模式（下）



设计模式综合应用实例



多人联机射击游戏

多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式

多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式



数据库同步系统

设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式

设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式

设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式

##  [GitBook 图书 ](https://gof.quanke.name/)

## [http://www.runoob.com/ 设计模式](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)


