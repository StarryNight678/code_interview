# Java设计模式

## 图书

1. 《大话设计模式》（程杰）
1. 《设计模式》（刘伟，清华大学出版社）
1. 强烈推荐《设计模式之禅》

##　看图书

![](https://images-cn.ssl-images-amazon.com/images/I/51xb%2B7p9wTL._SY498_BO1,204,203,200_.jpg)


## 学习[史上最全设计模式导学目录（完整版）](http://blog.csdn.net/lovelion/article/details/17517213)


![](http://i.imgur.com/LlG4WlO.png)

基础知识
 
设计模式概述
从招式与内功谈起——设计模式概述（一）：设计模式从何而来？
从招式与内功谈起——设计模式概述（二）：设计模式是什么？
从招式与内功谈起——设计模式概述（三）：设计模式有什么用？附：个人观点


这三个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致

1. 单一职责原则  一个类只负责一个功能领域中的相应职责
1. 开闭原则 软件实体应对扩展开放，而对修改关闭(抽象化是开闭原则的关键)
	系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
1. 里氏代换原则 所有引用基类对象的地方能够透明地使用其子类的对象
	在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。

	因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

	里氏代换原则是实现开闭原则的重要方式之一。

1. 依赖倒转原则 抽象不应该依赖于细节，细节应该依赖于抽象
	要针对接口编程，而不是针对实现编程。



1. 接口隔离原则 使用多个专门的接口，而不使用单一的总接口
	即客户端不应该依赖那些它不需要的接口。

	在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。

1. 合成复用原则 尽量使用对象组合，而不是继承来达到复用的目的
	组合降低耦合度
1. 迪米特法则 一个软件实体应当尽可能少地与其他实体发生相互作用
	迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。


 
# 六个创建型模式
 
在所有的工厂模式中，我们都强调一点：两个类A和B之间的关系应该**仅仅是A创建B或是A使用B，而不能两种关系都有。**

## 简单工厂模式-Simple Factory Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】

简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。


工厂三兄弟之简单工厂模式（一）：图表库的设计

工厂三兄弟之简单工厂模式（二）：简单工厂模式概述

工厂三兄弟之简单工厂模式（三）：图表库的简单工厂模式解决方案

工厂三兄弟之简单工厂模式（四）：图表库解决方案的改进，简单工厂模式的简化，简单工厂模式总结


简单工厂模式的主要优点如下：

(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。

(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。

(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。


简单工厂模式的主要缺点如下：

(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。

(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。

(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。

(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

   简单工厂模式虽然简单，但存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品，这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生，本文将介绍第二种工厂模式——工厂方法模式。



##　工厂方法模式-Factory Method Pattern【学习难度：★★☆☆☆，使用频率：★★★★★】

工厂三兄弟之工厂方法模式（一）：日志记录器的设计

工厂三兄弟之工厂方法模式（二）：工厂方法模式概述

工厂三兄弟之工厂方法模式（三）：日志记录器的工厂方法模式解决方案，反射与配置文件

工厂三兄弟之工厂方法模式（四）：重载的工厂方法，工厂方法的隐藏，工厂方法模式总结

工厂方法模式(Factory Method Pattern)：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。
工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)
，又可称作**虚拟构造器模式**(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。工厂方法模式是一种类创建型模式

![](http://img.blog.csdn.net/20130712102729562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 - 工厂方法模式的主要优点如下：
 
 (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
 
 (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类。
 
 (3) 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开

 
 - 工厂方法模式的主要缺点如下：
 
 (1) 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
 
 (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实

 

## 抽象工厂模式-Abstract  Factory Pattern【学习难度：★★★★☆，使用频率：★★★★★】

工厂三兄弟之抽象工厂模式（一）：界面皮肤库的初始设计

工厂三兄弟之抽象工厂模式（二）：产品等级结构与产品族

工厂三兄弟之抽象工厂模式（三）：抽象工厂模式概述

工厂三兄弟之抽象工厂模式（四）：界面皮肤库的抽象工厂模式解决方案

工厂三兄弟之抽象工厂模式（五）：“开闭原则”的倾斜性，抽象工厂模式总结

将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。


抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，它是一种对象创建型模式。


在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种性质称为“开闭原则”的倾斜性。


 **抽象工厂模式的主要优点如下：**
 
 (1) 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。
 
 (2) 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。
 
 (3) 增加新的产品族很方便，无须修改已有系统，符合“开

**抽象工厂模式的主要缺点如下：**

增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，
这显然会带来较大的不便，违背了“开闭原则”。
 


## 单例模式-Singleton Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】

确保对象的唯一性——单例模式 （一）：单例模式的动机，单例模式概述

确保对象的唯一性——单例模式 （二）：负载均衡器的设计与实现

确保对象的唯一性——单例模式 （三）：饿汉式单例与懒汉式单例的讨论

确保对象的唯一性——单例模式 （四）：一种更好的单例实现方法（静态内部类）

确保对象的唯一性——单例模式 （五）：单例模式总结

Windows任务管理器．只能启动一个．

单例模式：


单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，
这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。


```java
class TaskManager
{
     private static TaskManager tm = null;//静态类型的私有成员变量
     private TaskManager() {……} //构造函数改为private，
     public static TaskManager getInstance()//静态方法,创建实例
     {
        if (tm == null)
        {
            tm = new TaskManager();
        }
        return tm;
    }
   ……
}
```


问题,当创建实例慢,多线程中,容易创建多个实例.


### 饿汉式单例与懒汉式单例的讨论

饿汉式单例类是实现起来最简单的单例类
定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象

```java
class EagerSingleton { 
    private static final EagerSingleton instance = new EagerSingleton(); 
    private EagerSingleton() { } 

    public static EagerSingleton getInstance() {
        return instance; 
    }   
}
```


在类加载时并不自行实例化，这种技术又称为延迟加载(Lazy Load)技术，即需要的时候再加载实例，
为了避免多个线程同时调用getInstance()方法，我们可以使用关键字**synchronized，**

**synchronized**加锁.

```java

class LazySingleton { 
    private static LazySingleton instance = null; 

    private LazySingleton() { } 

    synchronized public static LazySingleton getInstance() { 
        if (instance == null) {
            instance = new LazySingleton(); 
        }
        return instance; 
    }
}
```

因此需要进行进一步改进，在synchronized中再进行一次(instance == null)判断，这种方式称为双重检查锁定(Double-Check Locking)。

**需要在静态成员变量instance之前增加修饰符volatile，**

```java

class LazySingleton { 
    private volatile static LazySingleton instance = null; 

    private LazySingleton() { } 

    public static LazySingleton getInstance() { 
        //第一重判断
        if (instance == null) {
            //锁定代码块
            synchronized (LazySingleton.class) {
                //第二重判断
                if (instance == null) {
                    instance = new LazySingleton(); //创建单例实例
                }
            }
        }
        return instance; 
    }
}
```

饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；
从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。
但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，
因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象
加载时间可能会比较长。

懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个
线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化
很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等
机制进行控制，这将导致系统性能受到一定影响。


### 静态内部类, 一种更好的单例实现方法

该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，

由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。
静态变量初始化一次.

通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，
不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）。


```java
//Initialization on Demand Holder
class Singleton {
	private Singleton() {
	}
	
	private static class HolderClass {
            private final static Singleton instance = new Singleton();
	}
	
	public static Singleton getInstance() {
	    return HolderClass.instance;
	}
	
	public static void main(String args[]) {
	    Singleton s1, s2; 
            s1 = Singleton.getInstance();
	    s2 = Singleton.getInstance();
	    System.out.println(s1==s2);
	}
}
```


- 单例模式的主要优点如下：

(1) 单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。

(2) 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。

(3) 允许可变数目的实例。基于单例模式我们可以进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例，既节省系统资源，又解决了单例单例对象共享过多有损


- 单例模式的主要缺点如下：

(1) 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。

(2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。

(3) 现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象


### 枚举类

关于单例模式的实现有很多种，网上也分析了如今实现单利模式最好用枚举，好处不外乎三点：

1.线程安全 2.不会因为序列化而产生新实例 3.防止反射攻击

```java
public enum Singleton {
    INSTANCE {

        @Override
        protected void read() {
            System.out.println("read");
        }

        @Override
        protected void write() {
            System.out.println("write");
        }

    };
    protected abstract void read();
    protected abstract void write();
}
```


## 原型模式-Prototype Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

对象的克隆——原型模式（一）：大同小异的工作周报，原型模式概述

对象的克隆——原型模式（二）：工作周报的原型模式解决方案

对象的克隆——原型模式（三）：带附件的周报【浅克隆，深克隆】

对象的克隆——原型模式（四）：原型管理器的引入和实现，原型模式总结


可以通过一个原型对象克隆出多个一模一样的对象，该模式称之为原型模式。

**原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式是一种对象创建型模式。**


```java
class ConcretePrototype implements Prototype
{
    private String  attr; //成员属性
    public void  setAttr(String attr)
    {
        this.attr = attr;
    }
    public String  getAttr()
    {
        return this.attr;
    }
    public Prototype  clone() //克隆方法
    {
        Prototype  prototype = new ConcretePrototype(); //创建新对象
        prototype.setAttr(this.attr);
        return prototype;
    }
}
```


在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。
序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。
通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，
因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。
需要注意的是能够实现序列化的对象其类必须实现Serializable接口，
否则无法实现序列化操作。下面我们使用深克隆技术来实现工作周报和附件对象的复制，由于要将附件对象和工作周报对象都写入流中，因此两个类均需要实现Serializable接口，其结构如图7-7所示：





## 建造者模式-Builder Pattern【学习难度：★★★★☆，使用频率：★★☆☆☆】

复杂对象的组装与创建——建造者模式（一）：游戏角色设计，建造者模式概述

复杂对象的组装与创建——建造者模式（二）：游戏角色设计的建造者模式解决方案

复杂对象的组装与创建——建造者模式（三）：关于Director的进一步讨论，建造者模式总结

 

# 七个结构型模式

 

##　适配器模式-Adapter Pattern【学习难度：★★☆☆☆，使用频率：★★★★☆】

不兼容结构的协调——适配器模式（一）：没有源码的算法库，适配器模式概述

不兼容结构的协调——适配器模式（二）：没有源码的算法库的适配器模式解决方案

不兼容结构的协调——适配器模式（三）：类适配器，双向适配器

不兼容结构的协调——适配器模式（四）：缺省适配器，适配器模式总结



##　桥接模式-Bridge Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

处理多维度变化——桥接模式（一）：跨平台图像浏览系统

处理多维度变化——桥接模式（二）：桥接模式概述

处理多维度变化——桥接模式（三）：跨平台图像浏览系统的桥接模式解决方案

处理多维度变化——桥接模式（四）：适配器模式与桥接模式的联用，桥接模式总结



##　组合模式-Composite Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

树形结构的处理——组合模式（一）：设计杀毒软件的框架结构

树形结构的处理——组合模式（二）：组合模式概述

树形结构的处理——组合模式（三）：杀毒软件的框架结构的组合模式解决方案

树形结构的处理——组合模式（四）：透明组合模式与安全组合模式

树形结构的处理——组合模式（五）：公司组织结构，组合模式总结



##　装饰模式-Decorator Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

扩展系统功能——装饰模式（一）：图形界面构件库的设计

扩展系统功能——装饰模式（二）：装饰模式概述

扩展系统功能——装饰模式（三）：图形界面构件库的装饰模式解决方案

扩展系统功能——装饰模式（四）：透明装饰模式与半透明装饰模式，装饰模式注意事项，装饰模式总结

我们也有一种类似新房装修的技术可以对已有对象（新房）的功能进行扩展（装修），
以获得更加符合用户需求的对象，使得对象具有更加强大的功能。这种技术对应于一种被
称之为装饰模式的设计模式

  装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，
  使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，
  在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。


**装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，
装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。**

装饰模式的核心在于抽象装饰类的设计，

![](http://my.csdn.net/uploads/201204/04/1333528185_7832.gif)

1. Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。
1. ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
1. Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。
1. ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。

由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方式动态
地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么
不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。

```java
class Decorator implements Component
{
       private Component component;  //维持一个对抽象构件对象的引用
       public Decorator(Component component)  //注入一个抽象构件类型的对象
       {
              this.component=component;
       }
 
       public void operation()
       {
              component.operation();  //调用原有业务方法
       }
}
```

在Decorator的子类即具体装饰类中将继承operation()方法并根据需要进行扩展，
典型的具体装饰类代码如下

```java
class ConcreteDecorator extends Decorator
{
       public ConcreteDecorator(Component  component)
       {
              super(component);
       }
 
       public void operation()
       {
              super.operation();  //调用原有业务方法
              addedBehavior();  //调用新增业务方法
       }
 
     //新增业务方法
       public  void addedBehavior()
       {    
         ……
}
}
```

![](http://my.csdn.net/uploads/201204/04/1333528353_8435.gif)



```java
//抽象界面构件类：抽象构件类，为了突出与模式相关的核心代码，对原有控件代码进行了大量的简化
abstract class Component
{
       public  abstract void display();
}
 
//窗体类：具体构件类
class Window extends Component
{
       public  void display()
       {
              System.out.println("显示窗体！");
       }
}
 
//文本框类：具体构件类
class TextBox extends Component
{
       public  void display()
       {
              System.out.println("显示文本框！");
       }
}
 
//列表框类：具体构件类
class ListBox extends Component
{
       public  void display()
       {
              System.out.println("显示列表框！");
       }
}
 
//构件装饰类：抽象装饰类
class ComponentDecorator extends Component
{
       private Component component;  //维持对抽象构件类型对象的引用
 
       public ComponentDecorator(Component  component)  //注入抽象构件类型的对象
       {
              this.component = component;
       }
 
       public void display()
       {
              component.display();
       }
}
 
//滚动条装饰类：具体装饰类
class ScrollBarDecorator extends  ComponentDecorator
{
       public ScrollBarDecorator(Component  component)
       {
              super(component);
       }
 
       public void display()
       {
              this.setScrollBar();
              super.display();
       }
 
       public  void setScrollBar()
       {
              System.out.println("为构件增加滚动条！");
       }
}
 
//黑色边框装饰类：具体装饰类
class BlackBorderDecorator extends  ComponentDecorator
{
       public BlackBorderDecorator(Component  component)
       {
              super(component);
       }
 
       public void display()
       {
              this.setBlackBorder();
              super.display();
       }
 
       public  void setBlackBorder()
       {
              System.out.println("为构件增加黑色边框！");
       }
}
```


      编写如下客户端测试代码：
```java
class Client
{
       public  static void main(String args[])
       {
              Component component,componentSB;  //使用抽象构件定义
              component = new Window(); //定义具体构件
              componentSB = new  ScrollBarDecorator(component); //定义装饰后的构件
              componentSB.display();
       }
}
```

在客户端代码中，我们先定义了一个Window类型的具体构件对象component，
然后将component作为构造函数的参数注入到具体装饰类ScrollBarDecorator中，
得到一个装饰之后对象componentSB，再调用componentSB的display()方法后将得到一个
有滚动条的窗体。如果我们希望得到一个既有滚动条又有黑色边框的窗体
，不需要对原有类库进行任何修改，只需将客户端代码修改为如下所示：

```java
class Client
{
       public  static void main(String args[])
       {
              Component  component,componentSB,componentBB; 
              //全部使用抽象构件定义
              component = new Window();
              componentSB = new  ScrollBarDecorator(component);
              componentBB = new  BlackBorderDecorator(componentSB); 
              //将装饰了一次之后的对象继续注入到另一个装饰类中，进行第二次装饰
              componentBB.display();
       }
}
```

如果需要在原有系统中增加一个新的具体构件类或者新的具体装饰类，
无须修改现有类库代码，只需将它们分别作为抽象构件类或者抽象装饰类的子类即可。
与图12-2所示的继承结构相比，使用装饰模式之后将大大减少了子类的个数，让系统
扩展起来更加方便，而且更容易维护，是取代继承复用的有效方式之一。


### 透明装饰模式与半透明装饰模式


在实际使用过程中，由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，
这种装饰模式被称为半透明(Semi-transparent)装饰模式，而标准的装饰模式是透明(Transparent)
装饰模式。下面我们对这两种装饰模式进行较为详细的介绍：

- 半透明装饰模式

具体装饰类单独增加新方法,新增行为可能需要单独调用,称为半透明装饰模式.

- 透明装饰模式中，要求客户端完全针对抽象编程

透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别
此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象



- 装饰模式的主要优点如下：

(1) 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。

(2) 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。

(3) 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。

(4) 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。



- 装饰模式的主要缺点如下：

(1) 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。

(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。





##　外观模式-Facade Pattern【学习难度：★☆☆☆☆，使用频率：★★★★★】

深入浅出外观模式（一）：外观模式概述，外观模式结构与实现

深入浅出外观模式（二）：外观模式应用实例（文件加密模块）

深入浅出外观模式（三）：抽象外观类，外观模式效果与适用场景



##　享元模式-Flyweight Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】

实现对象的复用——享元模式（一）：围棋棋子的设计，享元模式概述（上）

实现对象的复用——享元模式（二）：享元模式概述（下）

实现对象的复用——享元模式（三）：围棋棋子的享元模式解决方案

实现对象的复用——享元模式（四）：带外部状态的围棋棋子解决方案

实现对象的复用——享元模式（五）：单纯享元模式和复合享元模式，关于享元模式的几点补充，享元模式总结



##　代理模式-Proxy Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

代理模式（一）：代理模式概述，代理模式结构与实现

代理模式（二）：代理模式应用实例（收费商务信息查询系统）

代理模式（三）：远程代理，虚拟代理，缓冲代理

代理模式（四）：代理模式效果与适用场景



十一个行为型模式

 

##　职责链模式-Chain of Responsibility Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】

请求的链式处理——职责链模式（一）：采购单的分级审批

请求的链式处理——职责链模式（二）：职责链模式概述

请求的链式处理——职责链模式（三）：采购单分级审批的职责链模式解决方案

请求的链式处理——职责链模式（四）：纯与不纯的职责链模式，职责链模式总结



##　命令模式-Command Pattern【学习难度：★★★☆☆，使用频率：★★★★☆】

请求发送者与接收者解耦——命令模式（一）：自定义功能键，命令模式概述

请求发送者与接收者解耦——命令模式（二）：自定义功能键的命令模式解决方案

请求发送者与接收者解耦——命令模式（三）：命令队列的实现

请求发送者与接收者解耦——命令模式（四）：撤销操作的简单实现

请求发送者与接收者解耦——命令模式（五）：请求日志

请求发送者与接收者解耦——命令模式（六）：宏命令，命令模式总结



##　解释器模式-Interpreter Pattern【学习难度：★★★★★，使用频率：★☆☆☆☆】

自定义语言的实现——解释器模式（一）：机器人控制程序

自定义语言的实现——解释器模式（二）：文法规则和抽象语法树

自定义语言的实现——解释器模式（三）：解释器模式概述

自定义语言的实现——解释器模式（四）：机器人控制程序的解释器模式解决方案

自定义语言的实现——解释器模式（五）：再谈Context的作用

自定义语言的实现——解释器模式（六）：解释器模式总结



##　迭代器模式-Iterator Pattern【学习难度：★★★☆☆，使用频率：★★★★★】

遍历聚合对象中的元素——迭代器模式（一）：销售管理系统中数据的遍历

遍历聚合对象中的元素——迭代器模式（二）：迭代器模式概述

遍历聚合对象中的元素——迭代器模式（三）：销售管理系统中数据的遍历的迭代器模式解决方案

遍历聚合对象中的元素——迭代器模式（四）：使用内部类实现迭代器

遍历聚合对象中的元素——迭代器模式（五）：JDK内置迭代器的使用

遍历聚合对象中的元素——迭代器模式（六）：迭代器模式总结



##　中介者模式-Mediator Pattern【学习难度：★★★☆☆，使用频率：★★☆☆☆】

协调多个对象之间的交互——中介者模式（一）：客户信息管理窗口的初始设计

协调多个对象之间的交互——中介者模式（二）：中介者模式概述

协调多个对象之间的交互——中介者模式（三）：客户信息管理窗口的中介者模式解决方案

协调多个对象之间的交互——中介者模式（四）：中介者与同事类的扩展

协调多个对象之间的交互——中介者模式（五）：中介者模式总结



##　备忘录模式-Memento Pattern【学习难度：★★☆☆☆，使用频率：★★☆☆☆】

撤销功能的实现——备忘录模式（一）：可悔棋的中国象棋

撤销功能的实现——备忘录模式（二）：备忘录模式概述

撤销功能的实现——备忘录模式（三）：中国象棋的备忘录模式解决方案

撤销功能的实现——备忘录模式（四）：实现多次撤销

撤销功能的实现——备忘录模式（五）：再谈备忘录的封装，备忘录模式总结



##　观察者模式-Observer Pattern【学习难度：★★★☆☆，使用频率：★★★★★】

对象间的联动——观察者模式（一）：多人联机对战游戏的设计

对象间的联动——观察者模式（二）：观察者模式概述

对象间的联动——观察者模式（三）：多人联机对战游戏的观察者模式解决方案

对象间的联动——观察者模式（四）：JDK对观察者模式的支持

对象间的联动——观察者模式（五）：观察者模式与Java事件处理

对象间的联动——观察者模式（六）：观察者模式与MVC，观察者模式总结


```java

```

```java

```

```java

```


##　状态模式-State Pattern【学习难度：★★★☆☆，使用频率：★★★☆☆】

处理对象的多种状态及其相互转换——状态模式（一）：银行系统中的账户类设计

处理对象的多种状态及其相互转换——状态模式（二）：状态模式概述

处理对象的多种状态及其相互转换——状态模式（三）：账户类的状态模式解决方案

处理对象的多种状态及其相互转换——状态模式（四）：共享状态的实现

处理对象的多种状态及其相互转换——状态模式（五）：使用环境类实现状态转换

处理对象的多种状态及其相互转换——状态模式（六）：状态模式总结



##　策略模式-Strategy Pattern【学习难度：★☆☆☆☆，使用频率：★★★★☆】

算法的封装与切换——策略模式（一）：电影票打折方案

算法的封装与切换——策略模式（二）：策略模式概述

算法的封装与切换——策略模式（三）：电影票打折方案的策略模式解决方案

算法的封装与切换——策略模式（四）：策略模式的两个典型应用，策略模式总结



##　模板方法模式-Template Method Pattern【学习难度：★★☆☆☆，使用频率：★★★☆☆】

模板方法模式深度解析（一）：模板方法模式概述，模板方法模式结构与实现

模板方法模式深度解析（二）：模板方法模式应用实例（银行利息计算模块）

模板方法模式深度解析（三）：钩子方法的使用，模板方法模式效果与适用场景



##　访问者模式-Visitor Pattern【学习难度：★★★★☆，使用频率：★☆☆☆☆】

操作复杂对象结构——访问者模式（一）：OA系统中员工数据汇总

操作复杂对象结构——访问者模式（二）：访问者模式概述

操作复杂对象结构——访问者模式（三）：OA系统中员工数据汇总的访问者模式解决方案

操作复杂对象结构——访问者模式（四）：访问者模式与组合模式联用，访问者模式总结



设计模式趣味学习（复习）



设计模式与足球（一）：创建型模式

设计模式与足球（二）：结构型模式

设计模式与足球（三）：行为型模式（上）

设计模式与足球（四）：行为型模式（下）



设计模式综合应用实例



多人联机射击游戏

多人联机射击游戏中的设计模式应用（一）：抽象工厂模式，建造者模式，工厂方法模式，迭代器模式，命令模式

多人联机射击游戏中的设计模式应用（二）：观察者模式，单例模式，状态模式，适配器模式



数据库同步系统

设计模式综合实例分析之数据库同步系统（一）：数据库同步系统概述，建造者模式，简单工厂模式

设计模式综合实例分析之数据库同步系统（二）：享元模式，单例模式，观察者模式，模板方法模式

设计模式综合实例分析之数据库同步系统（三）：策略模式，组合模式，命令模式，职责链模式

##  [GitBook 图书 ](https://gof.quanke.name/)

## [http://www.runoob.com/ 设计模式](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)


