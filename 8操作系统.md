# 操作系统

并发性(concurrency)
–共享性(sharing)
–虚拟性(virtual)
–异步性(asynchronism)

OS Service

1. 用户接口
1. 程序执行
1. I/O操作
1. 通信服务
1. 错误处理
1. 资源管理


系统调用System Call

1. 由OS提供的一套编程接口
1. 库过程通常用C、C++、汇编语言编写
1. 只有系统调用可以进入内核


用程序来作为占用处理机的单位已不适合
程序与程序的执行不再一一对应


引入进程的好处：

1. 既能描述程序的并发性
1. 又能描述资源的共享性


进程和线程

– 资源所有权（Process）
– 调度的实体（Thread）

线程状态–就绪、运行、阻塞、终止

## 进程通信

1. 临界资源、临界区
1. 互斥与同步
1. 信号量和P、V操作

## 死锁

如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件（指：释放资源）那么，该进程是死锁的。


##  死锁的四个条件

1. 互斥控制
1. 占有等待
1. 非剥夺
1. 环路等待


死锁防止

1. 破坏第一条件（互斥条件）：只申请共享资源，适用于磁盘
1. 破坏第二条件（占有等待条件）：静态分配策略
1. 破坏第三条件（非剥夺条件）：适用于CPU、内存
1. 破坏第四条件（循环等待条件）：层次分配策略


银行家算法（动态预测算法）

死锁检测（Detection）

# 内存


逻辑地址物理地址？–在编译时产生绝对地址代码（内存中的位置事先确定，编译器/汇编器）–在加载时产生可重定位代码（内存中的位置事先无法确定，加载器）–在运行时进行地址重定位（内存中的位置事先无法确定，处理器）


放置算法（分配算法）

1. 首次适配First fit（从头扫描内存，选择大小足够的第一可用块）
1. 邻近适配Next fit（从上一次放置的位置扫描内存，选择大小足够的第一可用块）
1. 最佳适配Best fit（大小最接近，最小）
1. 最差适配Worst fit（最大）
1. 最快适配Quick fit（常用大小的空闲区维护单独链表）

## 分区管理的优缺点

1. 内存使用不充分，存在较严重的碎片问题
1. 要求进程的地址空间在内存中占据一个连续的区域
1. 虽然可通过“移动/拼接技术”消除碎片，但仍需移动大量信息，浪费处理机时间
1. 不能为用户提供“虚存”，即不能实现对内存的“扩充”，因此每个进程的存储要求仍受到内存大小的限制
1. 要求运行程序一次全部装入内存之后，才能运行


## 分段管理


将进程地址空间划分为若干个段

–程序加载时，分配其所需的所有段，这些段不必连续

–物理内存的管理采用动态分区

–需要CPU的硬件支持


S：段号
–P：页号
–W：页内地址


外存inode与内存inode

外存inode（外存文件控制块或外存索引节点）
–每个文件对应一个外存inode（该文件的FCB）
–这些inode被集中存放在文件存储设备上的inode区
–文件控制块inode作用相当于进程控制块proc
–找到inode就获得了它所对应的文件的一切必要信息
