
# 排序

## 内部排序

8大内部排序方法
![](http://www.lishiyu.cn/content/uploadfile/201409/1ae11410928597.jpg)

排序复杂度总结：

![](http://upload-images.jianshu.io/upload_images/273973-19cf4a1e58b6ebaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 待排序记录的存储方式：

1. 顺序表：存放在地址连续的一组存储单元中，记录之间的关系由存储位置决定，排序必须移动记录；**顺序表**
1. 静态链表：记录之间的关系由指针指示，排序不用移动记录，指向修改指针；**链表排序**
1. 附加地址：待排序记录本身存储在一组地址连续的存储单元内，同时附设一个指示记录存储位置的地址向量，排序过程中不移动记录，而移动地址向量中这些记录的地址，在排序结束后，再按照地址向量中的值调整记录的存储位置。**地址排序**

### 插入排序

1. Straight inserting based sorting (直接插入排序)

	稳定  
	平均复杂度 O（N^2）  
	最坏复杂度 O（N^2）  
	空间复杂度O（1）

	```
	void sort(int arr[],int size)
	{
		int tmp;
		int j;
		for (int i=1;i<size;i++)
		{
			tmp=arr[i];
			j=i-1;
			while ( tmp < arr[j] && j>=0)
			{
				arr[j+1]=arr[j];
				j--;
			}
			arr[j+1]=tmp;
		}
	}
	```

1. Dichotomy inserting based sorting (折半插入排序)

	**减少了比较的次数**
	由于插入排序的基本操作是在有序表中进行查找和插入，而查找的过程是可以用折半查找来实现的。由此实现的排序称为折半插入排序。
	性能分析：
	空间效率：同上
	时间效率：仅减少了比较次数，移动记录次数不变。
	折半插入排序是一个稳定的排序方法。

1. Two way inserting based sorting (二路插入排序)
	在2-路插入排序中，移动记录的次数约为n2/8。
	2-路插入排序需要n个辅助存储空间。


1. Shell sorting (希尔排序)  又称为缩小增量排序
	![](http://i.imgur.com/uncahqv.png)
	
    先将整个待排记录序列分割成若干个子序列分别进行直接插入排序，待整个序列中的记录“基本有序“时，再对全体记录进行一次直接插入排序，就可以完成整个的排序工作。

    不稳定  
	平均复杂度 O（N*logN）  
	最坏复杂度 O（N^3）  
	空间复杂度O（1）

    ```
    //希尔排序
	void xier(int arr[],int size,int d)
	{
		int  tmp;
		int Len[]={5,2,1};//递增的长度
		int LenLength=3;
		for (int a=0;a<LenLength;a++)
		{
			int len=Len[a];
			for (int i=len;i<size;i++)
			{
				tmp=arr[i];
				int j=i-len;
				while ( tmp < arr[j]  && j>=0)
				{
					arr[j+len]=arr[j];
					j=j-len;
				}
				arr[j+len]=tmp;
			}
		}
	}
    ```

- 总结

当序列基本有序时，直接插入排序的效率比较高。当个数很少时效率也比较高。

### Bubble sorting (冒泡排序)

稳定  
平均复杂度 O（N^2）  
最坏复杂度 O（N^2）  
空间复杂度O（1）

```
//冒泡排序
void maopao(int arr[],int size)
{
	for (int i=0;i<size-1;i++)
	{
		for (int j=0;j<size-1-i;j++)
		{
			if (arr[j]>arr[j+1])
			{
				int tmp=arr[j+1];
				arr[j+1]=arr[j];
				arr[j]=tmp;
			}
		}
	}
}

```


### Quick sorting (快速排序)

快速排序过程：

1. 首先任意选取一个记录作为枢轴（或支点）(Pivot)，然后按下述原则重新排列其一记录：	将所有关键字小于它的记录都安置在它之前，将所有关键字大于它的记录安置在它之后。
1. 于是以该枢轴记录所在的位置i作分界线，将整个序列分成两个子序列。这个过程称为一趟快速排序。
1. 然后分别对于两个子序列作同样的操作，重复这个过程，直到子序列不可再分就完成了记录的排序工作。

![](http://i.imgur.com/gJK2lID.png)
```
//快排
void kuaipai(int arr[],int arr_begin,int arr_end)
{
	if (arr_begin<=arr_end)
	{
		int flag=arr[arr_begin];
		int m=arr_begin;
		int n=arr_end;
		while(m<n)
		{
			while (arr[n]>=flag  && m<n)
			{
				n--;
			} 
			
			if (m<n)
			{
				arr[m]=arr[n];
			}

			while(arr[m]<=flag && m<n)
			{
				m++;
			} 
			if(m<n)
			{
				arr[n]=arr[m];	
			}
		}
		arr[m]=flag;
		kuaipai(arr,0,m-1);
		kuaipai(arr,m+1,arr_end);
	}
}
```

### 树形选择排序

树形选择排序 (Tree Selection Sort)，又称锦标赛排序 (Tournament Sort)。


每次两两比较的结果是把关键码小者作为优胜者上升到双亲结点，称这种**比赛树为胜者树**。

![](http://i.imgur.com/v4MZhCA.png)

![](http://i.imgur.com/ys52weE.png)

锦标赛排序构成的树是满的完全二叉树，其深度为 log2(n+1)，其中 n 待排序元素个数。
除第一次选择具有最小关键码的对象需要进行 n-1 次关键码比较外，重构胜者树选择具有次小、再次小关键码对象所需的关键码比较次数均为 O(log2n)。总关键码比较次数为O(nlog2n)。
对象的移动次数不超过关键码的比较次数，所以锦标赛排序总的时间复杂度为O(nlog2n)。


稳定  
平均复杂度 O（N*logN）

### 堆排序

锦标赛排序的时间复杂度为O(nlogN)。缺点是使用了较多的辅助空间，并且和“最大值”进行了多余的比较。1964年Willioms 提出了堆排序。

堆顶元素必为序列中n个元素的最小值（或最大值）。如果在输出堆顶的最小值后，使得剩余n-1个元素的序列重又建成一个堆，则得到次小值。反复执行便能得到所有记录的有序序列，这个过程称为堆排序。

现在需要研究两个问题：

1. 如何由一个无序序列建成一个堆；
	解决方案：自下而上调整

 	![](http://i.imgur.com/sa8iVCk.png)

 	![](http://i.imgur.com/KXKmZ7T.png)

1. 如何在输出堆顶元素后，调整剩余元素使之成为一个新的堆。
	解决方案：自上而下调整

	![](http://i.imgur.com/l7FNH7h.png)

	![](http://i.imgur.com/G5GdCRx.png)


不稳定
时间复杂性为O(nlogn)
空间复杂性为O(1)



### 归并排序

归并的含义：归并是将两个或两个以上的有序表合并成一个有序表。

2－路归并排序: 

假设初始的序列含有n个记录，可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2或1的有序子序列；再两两归并，如此重复直到得到一个长度为n的有序序列为止。

稳定
很少用于内部排序
时间复杂性为O(nlogn)
空间复杂性为,和待排记录等量的空间

### 基数排序


基数排序则是一种借助于多关键字排序思想对单逻辑关键字进行排序的方法，不需要进行关键字的比较。

基数排序是借助“分配”和“收集”两种基本操作对单逻辑关键字进行排序的一种内部排序方法。
有的逻辑关键字可以看成是若干个关键字复合而成的。例如数值和字符串。

最高位优先法(Most Significant Digit First): 最高位关键字比较

第二种方法是从最次位关键字Kd-1开始进行排序，称为最低位优先法 (Least Significant Digit First)。

 两种方法的特点：MSD算法需要逐层分成若干个子序列，而LSD算法进行排序时，不必分成子序列，但对Ki(0 ≤ i ≤ d-1)进行排序时，只能用**稳定的排序方法。**

 第一趟分配对最低数位关键字进行，改变记录指针值将链表中的记录分配至10个链队列中去，每个队列中的记录关键字的个位数相等；第一趟收集是改变所有非空队列的队尾的指针域，令其指向下一个非空队列的队头记录，重新将10个队列中的记录链成一个链表；第二趟分配和收集是针对十位数位进行的，过程和个位数位相同。其他位数一样。


![](http://i.imgur.com/pZMQO0L.png)

![](http://i.imgur.com/6HehM1v.png)

![](http://i.imgur.com/snyI9Vx.png)


假设每个记录含d个关键字，每个关键字的取值范围为rd，则每趟分配的时间复杂度为O(n)，每一趟收集的时间复杂度为O(rd)，则总的时间复杂度为O(d×(n+rd))。
空间复杂度：增加了n+2rd个指针域的空间。


有1,000,000个8位的整数要进行排序，使用快速排序法，至少需要nlogn次比较，即2千万次，用基数排序法则只需要8*(1,000,000+10)，约8百万次。




## 外部排序