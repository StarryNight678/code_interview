# 查找


对查找表(字典)进行的操作主要有四个：
1. 检索、查询、插入元素和删除元素。
1. 存储方法：顺序法、散列法、二叉树法和B树
存储方法的选择：考虑检索效率、元素的插入和删除是否简便。
1. 检索效率的标准：检索过程中和关键码比较的次数，即平均检索长度ASL。


- 难点 

	- 二叉排序树和二叉平衡树
	- B树和B+树

## 静态查找表哦

静态查找表：顺序查找，二分查找，索引查找


```
typedef struct
{	int	key;
	int	other;
}DicElement;
Typedef struct
{
	DicElement	element[MAXNUM];
	int  n;		/* n < MAXNUM */
}SeqDictionary;
```


顺序查找的优缺点：

- 优点：简单且适用面广，对表的结构没有要求，无论记录是否按关键字有序都可应用。
- 缺点：效率低

- 二分查找

logn
折半查找法的优缺点：
优点：速度快
缺点：只能适用于有序表，且仅限于顺序存储结构

```
int  Binary_searching(int data[],int left,int right,int x)
{
	int m=0;
	while(left<=right)
	{
		cout<<left<<" -> "<<right<<endl;
		m=(left+right)/2;
		if (x==data[m])
		{
			return m;
		}
		if (x > data[m])
		{
			left=m+1;
		} 
		else
		{
			right=m-1;
		}
	} 
	return m;
}
```
## 动态查找表

- 动态查找表
- 二叉查找树

二叉排序(搜索)树 (Binary searching Tree)或者是一棵空二叉树；或者具有下列性质的二叉树：

1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
1. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
1. 它的左右子树也分别为二叉排序树。


算法:

- 查找

1. X < root.getKey(), 查找左子树
1. X > root.getKey(), 查找右子树
1. 直到找到或者NULL

- 插入

1. 如果二叉排序树为空，则新结点作为根结点；
2. 如果二叉排序树非空，则将新结点的关键码与根结点的关键码比较，若小于根结点的关键码，则将新结点插入到根结点的左子树中；否则，插入到右子树中；
3. 子树中的插入过程和树中的插入过程相同，如此进行下去，直到找到该结点，或者直到新结点成为叶子结点为止。

- 结论

**中序遍历二叉排序树可以得到一个关键字的有序序列.**

由此可见二叉排序树既有折半查找的特性，又采用了链表作存储结构。因此二叉排序树是动态查找表中的一种有效表示方法。


```
#include <iostream>
using namespace std;

typedef struct Node
{
	int data;
	Node * left;
	Node * right;
}*PNode;

//查询节点
int find(PNode root,int x)
{
	PNode p=root;

	while (p)
	{
		if (p->data== x)
		{
			return x;
		}
		if (x < p->data )
		{
			p=p->left;
		} 
		else
		{
			p=p->right;
		}
	}
	return -1;

}

//插入节点
PNode BSTinsert(PNode root,int N)
{
	PNode p=root;
	PNode pn=NULL;
	pn=new Node;
	pn->data= N;
	pn->left=NULL;
	pn->right=NULL;
	if (NULL==p)
	{
		return pn;
	}

	while(p)
	{
		if (p->data < N )
		{
			if (!p->right)
			{
				p->right=pn;
				break;
			}
			p=p->right;
		} 
		else
		{
			if (!p->left)
			{
				p->left=pn;
				break;
			}
			p=p->left;
		}
	}
	return pn;
	
}

//中序遍历
void BSTtravel(PNode root)
{
	//**中序遍历二叉排序树可以得到一个关键字的有序序列.**
	if (root)
	{
		BSTtravel(root->left);
		cout<<root->data<<" ";
		BSTtravel(root->right);
	}
}

int main(int argc, char *argv[])
{
	int size =9;
	//data
	PNode root=NULL;
	int data[]={53, 78, 65, 17, 87, 9, 81, 45, 23 };
	root=BSTinsert(root,data[0]);
	for (int i=1;i<size;i++)
	{
		BSTinsert(root,data[i]);
	}
	BSTtravel(root);
	cout<<endl;

	cout<< find(root,77)<<endl;
	return 1;
}

```
- 平衡二叉树   AVL树
- B树 B+树
- 键树

## 哈希表

哈希查找表 哈希函数、冲突及解决策略
