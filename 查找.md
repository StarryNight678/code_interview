# 查找


对查找表(字典)进行的操作主要有四个：
1. 检索、查询、插入元素和删除元素。
1. 存储方法：顺序法、散列法、二叉树法和B树
存储方法的选择：考虑检索效率、元素的插入和删除是否简便。
1. 检索效率的标准：检索过程中和关键码比较的次数，即平均检索长度ASL。


- 难点 

	- 二叉排序树和二叉平衡树
	- B树和B+树

## 静态查找表

静态查找表：顺序查找，二分查找，索引查找


```
typedef struct
{	int	key;
	int	other;
}DicElement;
Typedef struct
{
	DicElement	element[MAXNUM];
	int  n;		/* n < MAXNUM */
}SeqDictionary;
```


顺序查找的优缺点：

- 优点：简单且适用面广，对表的结构没有要求，无论记录是否按关键字有序都可应用。
- 缺点：效率低

- 二分查找

```
具有12个关键字的有序表,折半查找的平均查找长度()
A 3.1
B 4
C 2.5
D 5

二分查找时：
第一层需要比较1次
第二两个数，每个比较2次
第三层四个数，每个比较3次
第四层五个数，每个比较4次
则平均查找长度即为：（1+2*2+3*4+4*5）/12 = 37/12 = 3.0833 即为 A 3.1
```

logn
折半查找法的优缺点：
优点：速度快
缺点：只能适用于有序表，且仅限于顺序存储结构

```
int  Binary_searching(int data[],int left,int right,int x)
{
	int m=0;
	while(left<=right)
	{
		cout<<left<<" -> "<<right<<endl;
		m=(left+right)/2;
		if (x==data[m])
		{
			return m;
		}
		if (x > data[m])
		{
			left=m+1;
		} 
		else
		{
			right=m-1;
		}
	} 
	return m;
}
```
## 动态查找表

- 动态查找表
- 二叉查找树

-  二叉排序(搜索)树 (Binary searching Tree)

或者是一棵空二叉树；或者具有下列性质的二叉树：

1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
1. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
1. 它的左右子树也分别为二叉排序树。


算法:

- 查找

1. X < root.getKey(), 查找左子树
1. X > root.getKey(), 查找右子树
1. 直到找到或者NULL

- 插入

1. 如果二叉排序树为空，则新结点作为根结点；
2. 如果二叉排序树非空，则将新结点的关键码与根结点的关键码比较，若小于根结点的关键码，则将新结点插入到根结点的左子树中；否则，插入到右子树中；
3. 子树中的插入过程和树中的插入过程相同，如此进行下去，直到找到该结点，或者直到新结点成为叶子结点为止。

- 节点删除(问题比较复杂)

	- 没有孩子结点

直接删除,修改父节点指针即可.

	- 只有左子树或只有右子树

只有左子树PL或只有右子树PR，此时，只要令PL或PR直接成为其双亲结点的左子树即可.

	- 左右子树均不空

	- 方法1

为保持其他元素之间的相对位置不变，可以有两种做法：其一是令*p的左子树为*f的左子树，而*p的右子树为*s（*p的直接前驱）的右子树.

	- 方法2

![](http://pic002.cnblogs.com/images/2012/457289/2012110918070093.jpg)

令*p的直接前驱（或直接后继）替代*p，然后从二叉排序树中删除它的直接前驱（或直接后继），如图d所示，当以*s代替*p时，由于*s只有左子树SL，则删除*s之后，只要令SL为*s的双亲结点*q的右子树即可。



- 结论

**中序遍历二叉排序树可以得到一个关键字的有序序列.**

无序的序列变成有序的序列.

- 插入作为根节点,不需要移动其他节点.


由此可见二叉排序树既有折半查找的特性，又采用了链表作存储结构。因此二叉排序树是动态查找表中的一种有效表示方法。


```
// 二叉排序(搜索)树
#include <iostream>
using namespace std;

typedef struct Node
{
	int data;
	Node * left;
	Node * right;
}*PNode;

//查询节点
int find(PNode root,int x)
{
	PNode p=root;

	while (p)
	{
		if (p->data== x)
		{
			return x;
		}
		if (x < p->data )
		{
			p=p->left;
		} 
		else
		{
			p=p->right;
		}
	}
	return -1;

}

//删除
void deleteNode_fun(PNode *p)
{
	PNode pre=NULL;
	if ( !(*p)->left)  //左子树为空
	{
		pre=(*p);
		(*p)= (*p)->right;
		delete(pre);
	} 
	else if( !(*p)->right )  //右子树为空
	{
		pre=(*p);
		(*p)= (*p)->left;
		delete(pre);
	}
	else //左右子树不为空
	{
		pre=(*p);
		PNode s=(*p)->left;
		while(s->right)
		{
			pre=s;
			s=s->right;
		}
		(*p)->data=s->data;
		if ((*p)!=pre) //重要的一点
		{
			pre->right=s->left;
		}else
		{
			pre->left=s->left;
		}
		delete(s);
	}
}

//删除节点
int deleteNode(PNode * p,int x)
{
	//PNode p=*root;
	if( *p )
	{
		if (x== ( (*p)->data ) )
		{
			deleteNode_fun( p );
			return x;
		} 
		else if(x < (*p)->data)
		{
			deleteNode(&(*p)->left,x);
		}else
		{
			deleteNode(&(*p)->right,x);
		}
	}
	return -1;
}



//插入节点
PNode BSTinsert(PNode root,int N)
{
	PNode p=root;
	PNode pn=NULL;
	pn=new Node;
	pn->data= N;
	pn->left=NULL;
	pn->right=NULL;
	if (NULL==p)
	{
		return pn;
	}

	while(p)
	{
		if (p->data < N )
		{
			if (!p->right)
			{
				p->right=pn;
				break;
			}
			p=p->right;
		} 
		else
		{
			if (!p->left)
			{
				p->left=pn;
				break;
			}
			p=p->left;
		}
	}
	return pn;

}

//中序遍历
void BSTtravel(PNode root)
{
	if (root)
	{
		//cout<<"----:"<<root->data<<endl;
		BSTtravel(root->left);
		cout<<root->data<<" ";
		BSTtravel(root->right);
	}
}

int main(int argc, char *argv[])
{
	int size =9;
	//data
	PNode root=NULL;
	int data[]={53, 78, 65, 17, 87, 9, 81, 45, 23 };
	root=BSTinsert(root,data[0]);
	for (int i=1;i<size;i++)
	{
		BSTinsert(root,data[i]);
	}
	cout<<"中序遍历"<<endl;
	BSTtravel(root);
	cout<<endl;
	cout<<"find 77"<<endl;
	cout<< find(root,77)<<endl;
	int del_int=9;
	cout<<"------------delete "<<del_int<<endl;
	deleteNode(&root,del_int);
	cout<<"中序遍历"<<endl;
	BSTtravel(root);
	cout<<endl;
	return 1;
}


```

- 平衡二叉树   AVL树

平衡二叉树又称AVL树。

它或者是一棵空树，或者是具有下列性质的二叉树：

1. 它的左右子树均为平衡二叉树
1. 左右子树的深度之差的绝对值不超过1。

平衡因子BF (Balance Factor)为该结点的左子树的深度减去右子树的深度。
BF只能是-1, 0, 1.

- 节点旋转

二叉排序树变成AVL树.通过节点旋转来实现.

![](https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)

旋转后的深度和插入前的相同.
当插入失去平衡时,仅需要对最小的不平衡旋转处理即可.不影响祖先节点的平衡度.


在平衡的二叉排序树BBST (Balancing Binary Search Tree)上插入一个新的数据元素e的递归算法可描述如下：


1. 若BBST为空树，则插入一个数据元素为e的新节点作为BBST的根节点，树的深度增1；
2. 若e的关键字和BBST的根节点的关键字相等，则不进行；
3. 若e的关键字小于BBST的根节点的关键字，而且在BBST的左子树中不存在和e有相同关键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：
	1. BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度，则将根节点的平衡因子更改为0，BBST的深度不变；
	2. BBST的根节点的平衡因子为0（左、右子树的深度相等）：则将根节点的平衡因子更改为1，BBST的深度增1；
	3. BBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：则若BBST的左子树根节点的平衡因子为1：则需进行单向右旋平衡处理，并且在右旋处理之后，将根节点和其右子树根节点的平衡因子更改为0，树的深度不变；
4. 若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关键字的节点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。

- 代码实现

**讲的非常清晰明白**

[二叉平衡树的插入和删除操作](http://www.cnblogs.com/Camilo/p/3917041.html)

重要的一点:

删除时,当删除节点有左右子树时:(注意替换的位置,保证仍为二叉平衡树)

1. 当待删除结点*T左子树的高度大于右子树的高度时，用*T的前驱结点pre代替*T，
再将结点pre从树中删除。这样可以保证删除结点后的树仍为二叉平衡树。

1. 当待删除结点*T左子树的高度小于或者等于右子树的高度时，用*T的后继结点post代替*T，
再将结点post从树中删除。这样可以保证删除结点后的树仍为二叉平衡树。

- 性能

时间复杂度：O(logn)


- 算法性能

```
算法		平均	    最差
空间		O(n)	    O(n)
搜索		O(log n)	O(log n)
插入		O(log n)	O(log n)
删除		O(log n)	O(log n)
```
- 最优二叉查找树

[最优二叉查找树（动态规划）](http://blog.csdn.net/xiajun07061225/article/details/8088784)

PH值最小的二叉树叫静态最优查找树.

注意:

1. 一棵最优二叉查找树不一定是一棵整体高度最小的树
1. 不一定总是把最大概率的关键字放在根部。

查找概率*查找长度的累积和.


给定一个由n个互异的关键字组成的序列K = (k1, k2, ……， kn）,且关键字有序（因此有k1 < k2 < …… < kn)，从这些关键字中构造一棵二叉查找树。对每个关键字ki， 一次搜索为ki的概率是pi。某些搜索的值可能不在K内，因此还有n + 1个“虚拟键”d0, d1, d2, ……dn代表不在K内的值，且ki ≤ di ≤ k(i+1)，di概率为qi。

因为搜索每个关键字的概率不同，因此最优二叉查找树即一棵期望搜索代价最小的二叉查找树。

从下图a), b)中可以看出，最优二叉查找树并不是高度最低的树，因为第一棵树期望是2.80，而第二棵是2.75。公式(15.10)显而易见。假设一次搜索的实际代价为检查的结点个数，亦即，在T内搜索所发现的结点的深度加上1， 所以一次搜索的期望代价为公式(15.11)，亦即，期望 = 深度 * 概率

![](http://mindlee.com/uploads/2011/09/The-optimal-binary-search-trees.jpg)

- 代价

N^3

- 次优查找树

[次优查找树的原理是什么？](https://www.zhihu.com/question/21063814)

解决最优查找树的构建效率低的问题.
，这种树的查找效率很少低于最优查找树的3%。


之前的折半查找树是为了让左右子树的高度差尽量小，现在你就把高度的概念替换为权值之和来理解，就好了。为什么要让**左右子树的权值累加**和之差最小？为了使树的深度最小。

- B树 

- B+树


- 键树

## 哈希表

哈希查找表 哈希函数、冲突及解决策略
