# 查找


对查找表(字典)进行的操作主要有四个：
1. 检索、查询、插入元素和删除元素。
1. 存储方法：顺序法、散列法、二叉树法和B树
存储方法的选择：考虑检索效率、元素的插入和删除是否简便。
1. 检索效率的标准：检索过程中和关键码比较的次数，即平均检索长度ASL。


- 难点 

	- 二叉排序树和二叉平衡树
	- B树和B+树

## 静态查找表

静态查找表：顺序查找，二分查找，索引查找


```
typedef struct
{	int	key;
	int	other;
}DicElement;
Typedef struct
{
	DicElement	element[MAXNUM];
	int  n;		/* n < MAXNUM */
}SeqDictionary;
```


顺序查找的优缺点：

- 优点：简单且适用面广，对表的结构没有要求，无论记录是否按关键字有序都可应用。
- 缺点：效率低

- 二分查找

```
具有12个关键字的有序表,折半查找的平均查找长度()
A 3.1
B 4
C 2.5
D 5

二分查找时：
第一层需要比较1次
第二两个数，每个比较2次
第三层四个数，每个比较3次
第四层五个数，每个比较4次
则平均查找长度即为：（1+2*2+3*4+4*5）/12 = 37/12 = 3.0833 即为 A 3.1
```

logn
折半查找法的优缺点：
优点：速度快
缺点：只能适用于有序表，且仅限于顺序存储结构

```
int  Binary_searching(int data[],int left,int right,int x)
{
	int m=0;
	while(left<=right)
	{
		cout<<left<<" -> "<<right<<endl;
		m=(left+right)/2;
		if (x==data[m])
		{
			return m;
		}
		if (x > data[m])
		{
			left=m+1;
		} 
		else
		{
			right=m-1;
		}
	} 
	return m;
}
```
## 动态查找表

- 动态查找表
- 二叉查找树

-  二叉排序(搜索)树 (Binary searching Tree)

或者是一棵空二叉树；或者具有下列性质的二叉树：

1. 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
1. 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
1. 它的左右子树也分别为二叉排序树。


算法:

- 查找

1. X < root.getKey(), 查找左子树
1. X > root.getKey(), 查找右子树
1. 直到找到或者NULL

- 插入

1. 如果二叉排序树为空，则新结点作为根结点；
2. 如果二叉排序树非空，则将新结点的关键码与根结点的关键码比较，若小于根结点的关键码，则将新结点插入到根结点的左子树中；否则，插入到右子树中；
3. 子树中的插入过程和树中的插入过程相同，如此进行下去，直到找到该结点，或者直到新结点成为叶子结点为止。

- 节点删除(问题比较复杂)

	- 没有孩子结点

直接删除,修改父节点指针即可.

	- 只有左子树或只有右子树

只有左子树PL或只有右子树PR，此时，只要令PL或PR直接成为其双亲结点的左子树即可.

	- 左右子树均不空

	- 方法1

为保持其他元素之间的相对位置不变，可以有两种做法：其一是令*p的左子树为*f的左子树，而*p的右子树为*s（*p的直接前驱）的右子树.

	- 方法2

![](http://pic002.cnblogs.com/images/2012/457289/2012110918070093.jpg)

令*p的直接前驱（或直接后继）替代*p，然后从二叉排序树中删除它的直接前驱（或直接后继），如图d所示，当以*s代替*p时，由于*s只有左子树SL，则删除*s之后，只要令SL为*s的双亲结点*q的右子树即可。



- 结论

**中序遍历二叉排序树可以得到一个关键字的有序序列.**

无序的序列变成有序的序列.

- 插入作为根节点,不需要移动其他节点.


由此可见二叉排序树既有折半查找的特性，又采用了链表作存储结构。因此二叉排序树是动态查找表中的一种有效表示方法。


```
// 二叉排序(搜索)树
#include <iostream>
using namespace std;

typedef struct Node
{
	int data;
	Node * left;
	Node * right;
}*PNode;

//查询节点
int find(PNode root,int x)
{
	PNode p=root;

	while (p)
	{
		if (p->data== x)
		{
			return x;
		}
		if (x < p->data )
		{
			p=p->left;
		} 
		else
		{
			p=p->right;
		}
	}
	return -1;

}

//删除
void deleteNode_fun(PNode *p)
{
	PNode pre=NULL;
	if ( !(*p)->left)  //左子树为空
	{
		pre=(*p);
		(*p)= (*p)->right;
		delete(pre);
	} 
	else if( !(*p)->right )  //右子树为空
	{
		pre=(*p);
		(*p)= (*p)->left;
		delete(pre);
	}
	else //左右子树不为空
	{
		pre=(*p);
		PNode s=(*p)->left;
		while(s->right)
		{
			pre=s;
			s=s->right;
		}
		(*p)->data=s->data;
		if ((*p)!=pre) //重要的一点
		{
			pre->right=s->left;
		}else
		{
			pre->left=s->left;
		}
		delete(s);
	}
}

//删除节点
int deleteNode(PNode * p,int x)
{
	//PNode p=*root;
	if( *p )
	{
		if (x== ( (*p)->data ) )
		{
			deleteNode_fun( p );
			return x;
		} 
		else if(x < (*p)->data)
		{
			deleteNode(&(*p)->left,x);
		}else
		{
			deleteNode(&(*p)->right,x);
		}
	}
	return -1;
}



//插入节点
PNode BSTinsert(PNode root,int N)
{
	PNode p=root;
	PNode pn=NULL;
	pn=new Node;
	pn->data= N;
	pn->left=NULL;
	pn->right=NULL;
	if (NULL==p)
	{
		return pn;
	}

	while(p)
	{
		if (p->data < N )
		{
			if (!p->right)
			{
				p->right=pn;
				break;
			}
			p=p->right;
		} 
		else
		{
			if (!p->left)
			{
				p->left=pn;
				break;
			}
			p=p->left;
		}
	}
	return pn;

}

//中序遍历
void BSTtravel(PNode root)
{
	if (root)
	{
		//cout<<"----:"<<root->data<<endl;
		BSTtravel(root->left);
		cout<<root->data<<" ";
		BSTtravel(root->right);
	}
}

int main(int argc, char *argv[])
{
	int size =9;
	//data
	PNode root=NULL;
	int data[]={53, 78, 65, 17, 87, 9, 81, 45, 23 };
	root=BSTinsert(root,data[0]);
	for (int i=1;i<size;i++)
	{
		BSTinsert(root,data[i]);
	}
	cout<<"中序遍历"<<endl;
	BSTtravel(root);
	cout<<endl;
	cout<<"find 77"<<endl;
	cout<< find(root,77)<<endl;
	int del_int=9;
	cout<<"------------delete "<<del_int<<endl;
	deleteNode(&root,del_int);
	cout<<"中序遍历"<<endl;
	BSTtravel(root);
	cout<<endl;
	return 1;
}


```

## 平衡二叉树   AVL树

平衡二叉树又称AVL树。

它或者是一棵空树，或者是具有下列性质的二叉树：

1. 它的左右子树均为平衡二叉树
1. 左右子树的深度之差的绝对值不超过1。

平衡因子BF (Balance Factor)为该结点的左子树的深度减去右子树的深度。
BF只能是-1, 0, 1.

- 节点旋转

二叉排序树变成AVL树.通过节点旋转来实现.

![](https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)

旋转后的深度和插入前的相同.
当插入失去平衡时,仅需要对最小的不平衡旋转处理即可.不影响祖先节点的平衡度.


在平衡的二叉排序树BBST (Balancing Binary Search Tree)上插入一个新的数据元素e的递归算法可描述如下：


1. 若BBST为空树，则插入一个数据元素为e的新节点作为BBST的根节点，树的深度增1；
2. 若e的关键字和BBST的根节点的关键字相等，则不进行；
3. 若e的关键字小于BBST的根节点的关键字，而且在BBST的左子树中不存在和e有相同关键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：
	1. BBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度，则将根节点的平衡因子更改为0，BBST的深度不变；
	2. BBST的根节点的平衡因子为0（左、右子树的深度相等）：则将根节点的平衡因子更改为1，BBST的深度增1；
	3. BBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：则若BBST的左子树根节点的平衡因子为1：则需进行单向右旋平衡处理，并且在右旋处理之后，将根节点和其右子树根节点的平衡因子更改为0，树的深度不变；
4. 若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关键字的节点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。

- 代码实现

**讲的非常清晰明白**

[二叉平衡树的插入和删除操作](http://www.cnblogs.com/Camilo/p/3917041.html)

重要的一点:

删除时,当删除节点有左右子树时:(注意替换的位置,保证仍为二叉平衡树)

1. 当待删除结点*T左子树的高度大于右子树的高度时，用*T的前驱结点pre代替*T，
再将结点pre从树中删除。这样可以保证删除结点后的树仍为二叉平衡树。

1. 当待删除结点*T左子树的高度小于或者等于右子树的高度时，用*T的后继结点post代替*T，
再将结点post从树中删除。这样可以保证删除结点后的树仍为二叉平衡树。

- 性能

时间复杂度：O(logn)


- 算法性能

```
算法		平均	    最差
空间		O(n)	    O(n)
搜索		O(log n)	O(log n)
插入		O(log n)	O(log n)
删除		O(log n)	O(log n)
```
## 最优二叉查找树

[最优二叉查找树（动态规划）](http://blog.csdn.net/xiajun07061225/article/details/8088784)

PH值最小的二叉树叫静态最优查找树.

注意:

1. 一棵最优二叉查找树不一定是一棵整体高度最小的树
1. 不一定总是把最大概率的关键字放在根部。

查找概率*查找长度的累积和.


给定一个由n个互异的关键字组成的序列K = (k1, k2, ……， kn）,且关键字有序（因此有k1 < k2 < …… < kn)，从这些关键字中构造一棵二叉查找树。对每个关键字ki， 一次搜索为ki的概率是pi。某些搜索的值可能不在K内，因此还有n + 1个“虚拟键”d0, d1, d2, ……dn代表不在K内的值，且ki ≤ di ≤ k(i+1)，di概率为qi。

因为搜索每个关键字的概率不同，因此最优二叉查找树即一棵期望搜索代价最小的二叉查找树。

从下图a), b)中可以看出，最优二叉查找树并不是高度最低的树，因为第一棵树期望是2.80，而第二棵是2.75。公式(15.10)显而易见。假设一次搜索的实际代价为检查的结点个数，亦即，在T内搜索所发现的结点的深度加上1， 所以一次搜索的期望代价为公式(15.11)，亦即，期望 = 深度 * 概率

![](http://mindlee.com/uploads/2011/09/The-optimal-binary-search-trees.jpg)

- 代价

N^3

- 次优查找树

[次优查找树的原理是什么？](https://www.zhihu.com/question/21063814)

解决最优查找树的构建效率低的问题.
，这种树的查找效率很少低于最优查找树的3%。


之前的折半查找树是为了让左右子树的高度差尽量小，现在你就把高度的概念替换为权值之和来理解，就好了。为什么要让**左右子树的权值累加**和之差最小？为了使树的深度最小。

## B树 

1. **B树，概括来说是一个一般化的二叉查找树（binary search tree），可以拥有多于2个子节点。**
1. **B树主要用于高维数据检索和文件的索引**

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/B-tree.svg/400px-B-tree.svg.png)


B树的定义：



一棵m阶的B树，或为空树，或是满足下列特性的m叉树：

1. 树中每个结点至多有m棵子树；
1. 若根结点不是叶子结点，则至少有两棵子树；
1. 除根之外的所有非终端结点至少有m/2棵子树；
1. 所有非终端结点中包含下列信息数据
(n, A0, K1, A1, K2, …, Kn, An)
1. 所有叶子结点都出现在同一层上，并且不带信息。实际上这些结点不存在，指向这些结点的指针为空

**m=2时，m阶B树实际上就是二叉排序树.**


与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实作上。

- 插入

注意:**节点的分裂**


B树的生成也是从空树起，逐个插入关键字而得。但由于B树结点中的关键字个数必须大于等于m/2－1，因此每次插入一个关键字不是在树中添加一个叶子结点，而是首先在最低层的非终端结点中添加一个关键字，若该结点关键字个数不超过m-1，则插入完成，否则，要产生结点的“分裂”。

插入是现在非终端节点


- 删除

首先找到该关键字所在结点，并从中删除之，若该结点为最下层的非终端结点，且其中的关键字数目不少于m/2，则删除完成，否则要进行**“合并结点”**的操作。



## B+树

**是应文件系统的需要而提出的一种B树的变形树。**

![](http://e.hiphotos.baidu.com/baike/s%3D220/sign=dbb4f87d8a26cffc6d2ab8b089034a7d/63d0f703918fa0ec640beae92e9759ee3c6ddb02.jpg)

1. 有n棵子树的结点中含有n个关键字；
1. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点的本身依关键的大小从小到大顺序链接。
1. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中最大（或最小）关键字。

**非终端节点只是索引.**

通常在B＋树上有两个头指针，一个指向根结点，另一个指向关键字最小的叶子结点。

- 插入删除

插入删除都只在叶节点上进行.

B+树的插入仅在叶结点上进行。每插入一个关键码-指针索引项后都要判断结点中的子树棵数是否超出范围。
B+树的删除仅在叶结点上进行。



- 为什么说B+树比B 树更适合实际应用中操作系统的文件索引和数据库索引？[2] 

	- B+树的磁盘读写代价更低
B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
	- B+树的查询效率更加稳定
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- 总结

一棵m阶的B+树和m阶的B树的异同点在于：
1. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。(而B 树的叶子节点并没有包括全部需要查找的信息)
1. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而B 树的非终节点也包含需要查找的有效信息)



## 哈希表

哈希函数的特性：
1. 函数值必须落在表长允许的范围内；
1. 对不同的关键字可能得到同一哈希地址。这种现象称为冲突(Collision)

- 构造Hash表

1. 直接地址法
取关键字或关键字的某个线性函数值为哈希地址。如年龄 H(key)=a*key+b

1. 数字分析法
 假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址
1. 平方取中法
取关键字平方后的中间几位为哈希地址。
1. 折叠法
将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为哈希地址。
1. 除留余数法
取关键字被某个不大于哈希表长度m的数p除后所得余数为哈希地址。
数p的选取：一般可选它为质数或不包含小于20的质因素的和数。
1. 随机数法
通常当关键字的长度不等时采用此法比较恰当

- 解决冲突的方法

1. 开放地址法

	`H=( H(key)+di )   MOD m`

	采用3种方法
	A.  di = 1, 2, 3, …, m-1, 称线性探测再散列；
	B.  di = 12, -12, 22, -22, …, k2, -k2(k <=m/2), 称为二次探测再散列；
	C.  di = 伪随机数序列，称伪随机探测再散列；


1. 再散列法
在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。
该法的优点是不易产生聚集，但增加了计算的时间。

1. 链地址法
将所有关键字为同义词的记录存储在同一线性链表中。

1. 溢出向量表
建立一个公共溢出区另设立一个溢出向量表，把所有冲突的关键字记录都填入溢出表。


- [红黑树](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png)

Red–black tree是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的：它可以在O(log n)时间内做查找，插入和删除，这里的n是树中元素的数目。


## 键树