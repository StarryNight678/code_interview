# 编程之法

共260页

# 1字符串


## 字符串旋转

- 题目描述

给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。

- 解法一：暴力移位法

m个字符.时间复杂度为O(m * n)，空间复杂度为O(1).

- 解法二: 三部反转

首先将原字符串分为两个部分，即X:abc，Y:def；
将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。

O(n)，空间复杂度为O(1).


## 字符串包含

题目描述

给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？
为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)

比如，如果是下面两个字符串：
String 1：ABCD
String 2：BAD
答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。

如果是下面两个字符串：
String 1：ABCD
String 2：BCE
答案是false，因为字符串String2里的E字母不在字符串String1里。
同时，如果string1：ABCD，string 2：AA，同样返回true。

- 解法一

判断string2中的字符是否在string1中?最直观也是最简单的思路是，针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。

需要O(n*m)

- 解法二

如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。

- 解法三

假设有一个仅由字母组成字串，让每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。

按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。
遍历长字符串，求得每个字符对应素数的乘积。
遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。
输出结果。

算法的时间复杂度为O(m+n)的最好的情况为O(n)

- 解法四

哈希或者位运算

进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。

```C
unsigned int bit_flag[100]={0};
void  my_bit_map(int num)
{
	int length=32;
	int m=num/length;
	int n=num%length;
	bit_flag[m] = bit_flag[m]  | (1<<n );
}

void print(unsigned int n)
{
	while (n)
	{
		cout<<n%2;
		n=n/2;
	}
}
```

## 字符串全排列

- 题目描述

输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串

abc、acb、bac、bca、cab 和 cba。


解法一、递归实现

```c
void CalcAllPermutation(char* perm, int from, int to)
{
	if (to <= 1)
	{
		return;
	}

	if (from == to)
	{
		for (int i = 0; i <= to; i++)
			cout << perm[i];
		cout << endl;
	}
	else
	{
		for (int j = from; j <= to; j++)
		{
			swap(perm[j], perm[from]);
			CalcAllPermutation(perm, from + 1, to);
			swap(perm[j], perm[from]);
		}
	}
}

int main()
{
	char perm[3]={'a','b','c'};
	CalcAllPermutation(perm,0,2);
	return 1;
}

```

- 核心部分

```c
for (int j = from; j <= to; j++)
{
	swap(perm[j], perm[from]);
	CalcAllPermutation(perm, from + 1, to);
	swap(perm[j], perm[from]);
}
```

a,b,c. 将后面的每个单词和第一个单词交换.都尝试下.
尝试完交换回来.



解法二、字典序排列

采用字典序方法,通过计算出下一个排列的方法得到所有的排列.

- 总结

由于全排列总共有n!种排列情况，所以不论解法一中的递归方法，还是上述解法二的字典序排列方法，这两种方法的时间复杂度都为O(n!)。


## 字符串转换为整数

题目描述

输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"123"，输出整数123。

给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。



1. 指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。
1. 正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。
1. 非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。
1. 整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。


## 回文判断

题目描述

回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。

那么，我们的第一个问题就是：判断一个字串是否是回文？

解法一

同时从字符串头尾开始向中间扫描字串.

```c
bool IsPalindrome(const char *s, int n)
{
    // 非法输入
    if (s == NULL || n < 1)
    {
        return false;
    }
    const char* front,*back;

    // 初始化头指针和尾指针
    front = s;
    back = s+ n - 1;

    while (front < back)
    {
        if (*front != *back)
        {
            return false;
        }
        ++front;
        --back;
    }
    return true;
}

```
这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：O(1)。


## 最长回文子串

题目描述

给定一个字符串，求它的最长回文子串的长度。


解法一 中心扩展法

那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：


```c
int LongestPalindrome(const char *s, int n)
{
    int i, j, max,c;
    if (s == 0 || n < 1)
        return 0;
    max = 0;
    for (i = 0; i < n; ++i) { // i is the middle point of the palindrome  
        for (j = 0; (i - j >= 0) && (i + j < n); ++j){ // if the length of the palindrome is odd  
            if (s[i - j] != s[i + j])
                break;
            c = j * 2 + 1;
        }
        if (c > max)
            max = c;
        for (j = 0; (i - j >= 0) && (i + j + 1 < n); ++j){ // for the even case  
            if (s[i - j] != s[i + j + 1])
                break;
            c = j * 2 + 2;
        }
        if (c > max)
            max = c;
    }
    return max;
}
```

代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。



解法二、O(N)解法

Manacher算法

```c
#include<iostream>
#include<vector>
using namespace std;
//
void fun(char input[],int n)
{
	char* s=new char[2*n+2];
	int* p=new int[2*n+2];
	int maxcount=-1;//最长回文长度
	int pos=-1;//回文中心位置
	int count=1;
	s[0]='$';
	s[1]='#';
	for (int i=0;i<n;i++)
	{
		count++;
		s[count]=input[i];
		count++;
		s[count]='#';
	}

	for (int i=0;i<2*n+2;i++)
	{
		cout<<s[i];
	}
	cout<<endl;

	int mx = 0;
	int id = 0;
	for (int i = 0;i<(2*n+2); i++) 
	{
		if ( mx > i)
		{
			p[i]=min(mx-i,p[2*id-i]);
		}
		else
		{
			p[i]=1;
		}

		while(s[i+p[i]]==s[i-p[i]]  && (i+p[i])<(2*n+2)  && (i-p[i])>=0)
		{
			p[i]++;
		}

		if (p[i]+i > mx)
		{
			mx=p[i]+i;
			id=i;
		}

	}

	for (int i=0;i<2*n+2;i++)
	{
		if(p[i]>maxcount)
		{
			maxcount=p[i];
			pos=i;
		}
	}
	cout<<"pos:"<<pos<<"  length:"<<p[pos]<<endl;
}

int main()
{
	char perm[6]={'d','a','b','c','b','a'};
	fun(perm,6);	
	return 1;
}
```

此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#。


![](http://i.imgur.com/5HD3BNy.png)

此Manacher算法使用id、mx做配合，可以在每次循环中，直接对P[i]的快速赋值，从而在计算以i为中心的回文子串的过程中，不必每次都从1开始比较，减少了比较次数，最终使得求解最长回文子串的长度达到线性O(N)的时间复杂度。


空间复杂度：插入分隔符形成新串，占用了线性的空间大小；RL数组也占用线性大小的空间，因此空间复杂度是线性的。
时间复杂度：尽管代码里面有两层循环，通过amortized analysis我们可以得出，Manacher的时间复杂度是线性的。由于内层的循环只对尚未匹配的部分进行，因此对于每一个字符而言，只会进行一次，因此时间复杂度是O(n)。


## [最长公共子序列](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/blob/master/ebook/zh/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.md)

- 问题描述 

 什么是最长公共子序列呢?好比一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。

举个例子，如：有两条随机序列，如 1 3 4 5 5 ，and 2 4 5 5 7 6，则它们的最长公共子序列便是：4 5 5。

**子序列不一定连续**

注意最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence, LCS）的区别：子串（Substring）是串的一个连续的部分，子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串acdfg同akdfc的最长公共子串为df，而他们的最长公共子序列是adf。LCS可以使用动态规划法解决。下文具体描述。

解法一

最容易想到的算法是穷举搜索法，即对X的每一个子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列，并且在检查过程中选出最长的公共子序列。X和Y的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的一个子序列相应于下标序列{1, 2, …, m}的一个子序列，因此，X共有2m个不同子序列（Y亦如此，如为2^n），从而穷举搜索法需要指数时间（2^m * 2^n）。



记：
Xi=﹤x1，⋯，xi﹥即X序列的前i个字符 (1≤i≤m)（前缀）

Yj=﹤y1，⋯，yj﹥即Y序列的前j个字符 (1≤j≤n)（前缀）

假定Z=﹤z1，⋯，zk﹥∈LCS(X , Y) 。

- 若xm=yn（最后一个字符相同），则不难用反证法证明：该字符必是X与Y的任一最长公共子序列Z（设长度为k）的最后一个字符，即有zk = xm = yn 且显然有Zk-1∈LCS(Xm-1 , Yn-1)即Z的前缀Zk-1是Xm-1与Yn-1的最长公共子序列。此时，问题化归成求Xm-1与Yn-1的LCS（LCS(X , Y)的长度等于LCS(Xm-1 , Yn-1)的长度加1）。

- 若xm≠yn，则亦不难用反证法证明：要么Z∈LCS(Xm-1, Y)，要么Z∈LCS(X , Yn-1)。由于zk≠xm与zk≠yn其中至少有一个必成立，若zk≠xm则有Z∈LCS(Xm-1 , Y)，类似的，若zk≠yn 则有Z∈LCS(X , Yn-1)。此时，问题化归成求Xm-1与Y的LCS及X与Yn-1的LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}。

由于上述当xm≠yn的情况中，求LCS(Xm-1 , Y)的长度与LCS(X , Yn-1)的长度，这两个问题不是相互独立的：两者都需要求LCS(Xm-1，Yn-1)的长度。另外两个序列的LCS中包含了两个序列的前缀的LCS，故问题具有最**优子结构性质考虑用动态规划法。**


**由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。**

也就是说，解决这个LCS问题，你要求三个方面的东西：1、LCS(Xm-1，Yn-1)+1；2、LCS(Xm-1，Y)，LCS(X，Yn-1)；3、max{LCS(Xm-1, Y)，LCS(X, Yn-1)}。

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/11/11.1.jpg)


**核心**

```c
if( x[i]=y[j] )
{
	c[i,j]=c[i-1,j-1]+1;
}else
{
c[i,j]:=Max( c[i,j-1],c[i-1,j] );
}
```

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/11/11.2.jpg)

c存储长度,b存储方向数据.沿着b的方向得到最长序列.打印"↖"即可找到.

```c
begin  
  m:=length[X];  
  n:=length[Y];  
  for i:=1 to m do c[i,0]:=0;
  for j:=1 to n do c[0,j]:=0;
      for i:=1 to m do  
        for j:=1 to n do  
            if x[i]=y[j] then  
              begin  
                c[i,j]:=c[i-1,j-1]+1;  
                b[i,j]:="↖";  
              end  
            else if c[i-1,j]≥c[i,j-1] then  
              begin  
                c[i,j]:=c[i-1,j];  
                b[i,j]:="↑";  
              end  
            else  
              begin  
                c[i,j]:=c[i,j-1];  
                b[i,j]:="←"  
              end;  
  return(c,b);  
end;  
```

### 算法改进

动态规划的一个计算最长公共子序列的方法如下，以两个序列 X、Y 为例子：

设有二维数组 f[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有：

```
f[1][1] = same(1,1)
f[i][j] = max{f[i − 1][j − 1] +same(i,j), f[i − 1][j] ,f[i][j − 1]}
```

其中，same(a,b)当 X 的第 a 位与 Y 的第 b 位完全相同时为“1”，否则为“0”。

此时，f[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。

该算法的空间、时间复杂度均为O(n2)，经过优化后，空间复杂度可为O(n)，时间复杂度为O(nlogn)。


- 举一反三

1、最长递增子序列LIS（Longest Increasing Subsequence）

给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4。

分析：其实此LIS问题可以转换成最长公子序列问题，为什么呢？

原数组为A {5， 6， 7， 1， 2， 8}
排序后：A‘{1， 2， 5， 6， 7， 8}
因为，原数组A的子序列顺序保持不变，而且排序后A‘本身就是递增的，这样，就保证了两序列的最长公共子序列的递增特性。如此，若想求数组A的最长递增子序列，其实就是求数组A与它的排序数组A‘的最长公共子序列。

# 2数组


## 2.1 寻找最小的k个数

题目描述

输入n个整数，输出其中最小的k个。

解法一

要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。

至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为n*logn），然后再遍历序列中前k个元素输出即可。因此，总的时间复杂度：O（n * log n)+O(k)=O（n * log n）。


解法二

咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：

1、遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
2、对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；
3、继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x < kmax ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组。

每次遍历，更新或不更新数组的所用的时间为O（k）或O（0）。故整趟下来，时间复杂度为n*O（k）=O（n*k）。


解法三

更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：

1、用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
2、堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
3、遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果x < kmax，用x替换kmax，然后更新堆（用时logk）；否则不更新堆。
这样下来，总的时间复杂度:O（k+（n-k）*logk）=** O（n*logk）**。此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)（若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。

解法四

在《数据结构与算法分析--c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为O（N）的快速选择算法。如下述文字：

- 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
- 如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。
- 如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
- 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。

此算法的平均运行时间为O(n)。


**更进一步，《算法导论》第9章第9.3节介绍了一个最坏情况下亦为O(n)时间的SELECT算法，有兴趣的读者可以参看。**

## 2.2 寻找和为定值的两个数

题目描述

输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。

要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。

例如输入数组1、2、4、7、11、15和数字15。由于4+11=15，因此输出4和11。

解法一

根据前面的分析，a[i]在序列中，如果a[i]+a[k]=sum的话，那么sum-a[i]（a[k])也必然在序列中。 举个例子，如下： 原始序列：

1、 2、 4、 7、11、15
用输入数字15减一下各个数，得到对应的序列为：

14、13、11、8、4、 0
第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，如果第一个数组出现了和第二个数组一样的数，即a[i]=a[j]，就找出这俩个数来了。 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15。 怎么样，两端同时查找，时间复杂度瞬间缩短到了O(N)，但却同时需要O(N)的空间存储第二个数组。

解法二

当题目对时间复杂度要求比较严格时，我们可以考虑下用空间换时间，上述解法一即是此思想，此外，构造hash表也是典型的用空间换时间的处理办法。

即给定一个数字，根据hash映射查找另一个数字是否也在数组中，只需用O(1)的时间，前提是经过O(N)时间的预处理，和用O(N)的空间构造hash表。

但能否做到在时间复杂度为O(N)的情况下，空间复杂度能进一步降低达到O(1)呢？

解法三

如果数组是无序的，**先排序(N log N)**，然后用两个指针i，j，各自指向数组的首尾两端，令i=0，j=n-1，然后i++，j--，逐次判断a[i]+a[j]?=sum，

如果某一刻a[i]+a[j] > sum，则要想办法让sum的值减小，所以此刻i不动，j--；
如果某一刻a[i]+a[j] < sum，则要想办法让sum的值增大，所以此刻i++，j不动。
所以，数组无序的时候，时间复杂度最终为O(N log N + N)=O(N log N)。



## 2.3 寻找和为定值的多个数

题目描述

输入两个整数n和sum，从数列1，2，3.......n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。


[背包问题九讲](http://love-oriented.com/pack/)




## 2.4 最大连续子数组和


题目描述

输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值，要求时间复杂度为O(n)。

例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2， 因此输出为该子数组的和18。

解法一

三个for循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组的最大的一个值。

```c
int MaxSubArray(int* A, int n)
{
    int maxSum = a[0];  //全负情况，返回最大负数
    int currSum = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = i; j < n; j++)
        {
            for (int k = i; k <= j; k++)
            {
                currSum += A[k];
            }
            if (currSum > maxSum)
                maxSum = currSum;

            currSum = 0; //这里要记得清零，否则的话sum最终存放的是所有子数组的和。
        }
    }
    return maxSum;
}
```



解法二


currSum 表示以j为结尾的连续子字符的和. 
**只有前面的大于0,才继续加**

1. 当currSum大于0, currSum += a[j];
1. 当currSum<0,currSum=a[j]



currSum = max(a[j], currSum + a[j])
maxSum = max(maxSum, currSum)
举个例子，当输入数组是1, -2, 3, 10, -4, 7, 2, -5，那么，currSum和maxSum相应的变化为：

currSum： 0 1 - 1 3 13 9 16 18 13
maxSum ： 0 1 1 3 13 13 16 18 18

## 2.5 跳台阶

题目描述

一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。

解法一

求总共有多少总跳法，并分析算法的时间复杂度。

当n>2时，第一次跳的时候就有两种不同的选择：
一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；
另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。
因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。


解法二

从前往后算

//1, 1, 2, 3, 5, 8, 13, 21..
int ClimbStairs(int n)
{
    int dp[3] = { 1, 1 };
    if (n < 2)
    {
        return 1;
    }
    for (int i = 2; i <= n; i++)
    {
        dp[2] = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = dp[2];
    }
    return dp[2];
}


## 2.6 奇偶排序

题目描述

输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求时间复杂度为O(n)。

```c
//判断是否为奇数
bool IsOddNumber(int data)
{
    return data & 1 == 1;
}
```

方法一

借鉴partition的实现一，我们可以考虑维护两个指针，一个指针指向数组的第一个数字，我们称之为头指针，向右移动；一个指针指向最后一个数字，称之为尾指针，向左移动。

这样，两个指针分别从数组的头部和尾部向数组的中间移动，如果第一个指针指向的数字是偶数而第二个指针指向的数字是奇数，我们就交换这两个数字。





## 2.7 荷兰国旗

- 题目描述

该问题本身是关于三色球排序和分类的，由荷兰科学家Dijkstra提出。由于问题中的三色小球有序排列后正好分为三类，Dijkstra就想象成他母国的国旗，于是问题也就被命名为荷兰旗问题（Dutch National Flag Problem）。

下面是问题的正规描述： 现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球、一些白球、一些蓝球。

通过前面的分析得知，这个问题类似快排中partition过程，只是需要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当

current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；
current指针所指元素为2时，与end指针所指的元素交换，而后，**current指针不动**，end-- 。
为什么上述第3点中，current指针所指元素为2时，与end指针所指元素交换之后，current指针不能动呢？因为第三步中current指针所指元素与end指针所指元素交换之前，如果end指针之前指的元素是0，那么与current指针所指元素交换之后，current指针此刻所指的元素是0，此时，current指针能动么？不能动，因为如上述第1点所述，如果current指针所指的元素是0，还得与begin指针所指的元素交换。

借鉴了快速排序的方法

![](https://camo.githubusercontent.com/39648f0f0b2a257306d5560958a2d79a5d5367a8/687474703a2f2f68692e6373646e2e6e65742f6174746163686d656e742f3230313130322f32352f383339343332335f31323938363431323235654a34462e6a7067)


## 2.8 矩阵相乘


## 2.9 完美洗牌


题目详情

有个长度为2n的数组{a1,a2,a3,...,an,b1,b2,b3,...,bn}，希望排序后{a1,b1,a2,b2,....,an,bn}，请考虑有无时间复杂度o(n)，空间复杂度0(1)的解法。

题目来源：此题是去年2013年UC的校招笔试题，看似简单，按照题目所要排序后的字符串蛮力变化即可，但若要完美的达到题目所要求的时空复杂度，则需要我们花费不小的精力。OK，请看下文详解，一步步优化。


# 3树

2–3树是一个这样的一棵树， 它的每个节点要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/2-3-4_tree_2-node.svg/110px-2-3-4_tree_2-node.svg.png)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/2-3-4-tree_3-node.svg/120px-2-3-4-tree_3-node.svg.png)

## 3.0统计出现次数最多的数据

题目描述

千万或上亿的数据,数据有重复,统计其中出现次数最多的前n个数据.



解法一 hash_map

hash_map 统计次数. 堆取出前n个数据.


解法二 红黑树

红黑树进行频率统计.利用堆取出前n个数据.

红黑树广泛应用.

C++,STL  set,map,muliset,mulimap.底层都是基于红黑树的.


二叉查找树操作

平均复杂度O(logn)  最坏O(n)


红黑树,本质上来说就是一棵二叉查找树,增加了着色和相关的性质使得红黑树相对平衡，从而保证了**红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。**

性质:

1. 每个结点要么是红的，要么是黑的。  
2. 根结点是黑的。  
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4. 如果一个结点是红的，那么它的俩个儿子都是黑的。  
5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的**黑结点。**

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png)

[红黑树 插入 删除操作](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)

## 3.1 红黑树
## 3.2 B树

题目描述

硬盘上有一个文本文件,一行一个人名. 找出"jason"的人.

许多数据库.都使用了B树或B树的各种变形结构

树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，因此我们该想办法降低树的深度，从而减少磁盘查找存取的次数。一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/7/1.jpg)


一棵含n个结点的B树的高度也为O(lgn)，但可能比一棵红黑树的高度小许多，因为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/7/2.jpg)

B树的定义

B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：

1. 树中每个结点最多含有m个孩子（m>=2）；
1. 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；
1. 根结点至少有2个孩子（除非B树只包含一个结点：根结点）；
1. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。
1. 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
	a) Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。
	b) Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
	c) 关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。



- 插入操作

1. 如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；
2. 如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。
3. 此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。





## 3.3 最近公共祖先LCA
## 3.10 本章习题


# 4查找
# 5动态规划
# 6海量数据处理
# 7机器学习
# 8其他题型
