# 编程之法

共260页

# 1字符串


## 字符串旋转

- 题目描述

给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。

- 解法一：暴力移位法

m个字符.时间复杂度为O(m * n)，空间复杂度为O(1).

- 解法二: 三部反转

首先将原字符串分为两个部分，即X:abc，Y:def；
将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。

O(n)，空间复杂度为O(1).


## 字符串包含

题目描述

给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？
为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)

比如，如果是下面两个字符串：
String 1：ABCD
String 2：BAD
答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。

如果是下面两个字符串：
String 1：ABCD
String 2：BCE
答案是false，因为字符串String2里的E字母不在字符串String1里。
同时，如果string1：ABCD，string 2：AA，同样返回true。

- 解法一

判断string2中的字符是否在string1中?最直观也是最简单的思路是，针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。

需要O(n*m)

- 解法二

如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。

- 解法三

假设有一个仅由字母组成字串，让每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。

按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。
遍历长字符串，求得每个字符对应素数的乘积。
遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。
输出结果。

算法的时间复杂度为O(m+n)的最好的情况为O(n)

- 解法四

哈希或者位运算

进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。

```C
unsigned int bit_flag[100]={0};
void  my_bit_map(int num)
{
	int length=32;
	int m=num/length;
	int n=num%length;
	bit_flag[m] = bit_flag[m]  | (1<<n );
}

void print(unsigned int n)
{
	while (n)
	{
		cout<<n%2;
		n=n/2;
	}
}
```

## 字符串全排列

- 题目描述

输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串

abc、acb、bac、bca、cab 和 cba。


解法一、递归实现

```c
void CalcAllPermutation(char* perm, int from, int to)
{
	if (to <= 1)
	{
		return;
	}

	if (from == to)
	{
		for (int i = 0; i <= to; i++)
			cout << perm[i];
		cout << endl;
	}
	else
	{
		for (int j = from; j <= to; j++)
		{
			swap(perm[j], perm[from]);
			CalcAllPermutation(perm, from + 1, to);
			swap(perm[j], perm[from]);
		}
	}
}

int main()
{
	char perm[3]={'a','b','c'};
	CalcAllPermutation(perm,0,2);
	return 1;
}

```

- 核心部分

```c
for (int j = from; j <= to; j++)
{
	swap(perm[j], perm[from]);
	CalcAllPermutation(perm, from + 1, to);
	swap(perm[j], perm[from]);
}
```

a,b,c. 将后面的每个单词和第一个单词交换.都尝试下.
尝试完交换回来.



解法二、字典序排列

采用字典序方法,通过计算出下一个排列的方法得到所有的排列.

- 总结

由于全排列总共有n!种排列情况，所以不论解法一中的递归方法，还是上述解法二的字典序排列方法，这两种方法的时间复杂度都为O(n!)。


## 字符串转换为整数

题目描述

输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"123"，输出整数123。

给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。



1. 指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。
1. 正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。
1. 非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。
1. 整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。


## 回文判断

题目描述

回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam、我爱我，这样的短句在智力性、趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。

那么，我们的第一个问题就是：判断一个字串是否是回文？

解法一

同时从字符串头尾开始向中间扫描字串.

```c
bool IsPalindrome(const char *s, int n)
{
    // 非法输入
    if (s == NULL || n < 1)
    {
        return false;
    }
    const char* front,*back;

    // 初始化头指针和尾指针
    front = s;
    back = s+ n - 1;

    while (front < back)
    {
        if (*front != *back)
        {
            return false;
        }
        ++front;
        --back;
    }
    return true;
}

```
这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：O(1)。


## 最长回文子串

题目描述

给定一个字符串，求它的最长回文子串的长度。


解法一 中心扩展法

那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：


```c
int LongestPalindrome(const char *s, int n)
{
    int i, j, max,c;
    if (s == 0 || n < 1)
        return 0;
    max = 0;
    for (i = 0; i < n; ++i) { // i is the middle point of the palindrome  
        for (j = 0; (i - j >= 0) && (i + j < n); ++j){ // if the length of the palindrome is odd  
            if (s[i - j] != s[i + j])
                break;
            c = j * 2 + 1;
        }
        if (c > max)
            max = c;
        for (j = 0; (i - j >= 0) && (i + j + 1 < n); ++j){ // for the even case  
            if (s[i - j] != s[i + j + 1])
                break;
            c = j * 2 + 2;
        }
        if (c > max)
            max = c;
    }
    return max;
}
```

代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。



解法二、O(N)解法

Manacher算法

```c
#include<iostream>
#include<vector>
using namespace std;
//
void fun(char input[],int n)
{
	char* s=new char[2*n+2];
	int* p=new int[2*n+2];
	int maxcount=-1;//最长回文长度
	int pos=-1;//回文中心位置
	int count=1;
	s[0]='$';
	s[1]='#';
	for (int i=0;i<n;i++)
	{
		count++;
		s[count]=input[i];
		count++;
		s[count]='#';
	}

	for (int i=0;i<2*n+2;i++)
	{
		cout<<s[i];
	}
	cout<<endl;

	int mx = 0;
	int id = 0;
	for (int i = 0;i<(2*n+2); i++) 
	{
		if ( mx > i)
		{
			p[i]=min(mx-i,p[2*id-i]);
		}
		else
		{
			p[i]=1;
		}

		while(s[i+p[i]]==s[i-p[i]]  && (i+p[i])<(2*n+2)  && (i-p[i])>=0)
		{
			p[i]++;
		}

		if (p[i]+i > mx)
		{
			mx=p[i]+i;
			id=i;
		}

	}

	for (int i=0;i<2*n+2;i++)
	{
		if(p[i]>maxcount)
		{
			maxcount=p[i];
			pos=i;
		}
	}
	cout<<"pos:"<<pos<<"  length:"<<p[pos]<<endl;
}

int main()
{
	char perm[6]={'d','a','b','c','b','a'};
	fun(perm,6);	
	return 1;
}
```

此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#。


![](http://i.imgur.com/5HD3BNy.png)

此Manacher算法使用id、mx做配合，可以在每次循环中，直接对P[i]的快速赋值，从而在计算以i为中心的回文子串的过程中，不必每次都从1开始比较，减少了比较次数，最终使得求解最长回文子串的长度达到线性O(N)的时间复杂度。



## 最长公共子序列


# 2数组
# 3树
# 4查找
# 5动态规划
# 6海量数据处理
# 7机器学习
# 8其他题型
