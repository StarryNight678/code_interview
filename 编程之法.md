# 编程之法

共260页

# 1字符串


## 字符串旋转

- 题目描述

给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符'a'和'b'移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。

- 解法一：暴力移位法

m个字符.时间复杂度为O(m * n)，空间复杂度为O(1).

- 解法二: 三部反转

首先将原字符串分为两个部分，即X:abc，Y:def；
将X反转，X->X^T，即得：abc->cba；将Y反转，Y->Y^T，即得：def->fed。
反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。

O(n)，空间复杂度为O(1).


## 字符串包含

题目描述

给定两个分别由字母组成的字符串A和字符串B，字符串B的长度比字符串A短。请问，如何最快地判断字符串B中所有字母是否都在字符串A里？
为了简单起见，我们规定输入的字符串只包含大写英文字母，请实现函数bool StringContains(string &A, string &B)

比如，如果是下面两个字符串：
String 1：ABCD
String 2：BAD
答案是true，即String2里的字母在String1里也都有，或者说String2是String1的真子集。

如果是下面两个字符串：
String 1：ABCD
String 2：BCE
答案是false，因为字符串String2里的E字母不在字符串String1里。
同时，如果string1：ABCD，string 2：AA，同样返回true。

- 解法一

判断string2中的字符是否在string1中?最直观也是最简单的思路是，针对string2中每一个字符，逐个与string1中每个字符比较，看它是否在String1中。

需要O(n*m)

- 解法二

如果允许排序的话，我们可以考虑下排序。比如可先对这两个字符串的字母进行排序，然后再同时对两个字串依次轮询。两个字串的排序需要(常规情况)O(m log m) + O(n log n)次操作，之后的线性扫描需要O(m+n)次操作。

- 解法三

假设有一个仅由字母组成字串，让每个字母与一个素数对应，从2开始，往后类推，A对应2，B对应3，C对应5，......。遍历第一个字串，把每个字母对应素数相乘。最终会得到一个整数。

按照从小到大的顺序，用26个素数分别与字符'A'到'Z'一一对应。
遍历长字符串，求得每个字符对应素数的乘积。
遍历短字符串，判断乘积能否被短字符串中的字符对应的素数整除。
输出结果。

算法的时间复杂度为O(m+n)的最好的情况为O(n)

- 解法四

哈希或者位运算

进一步，我们可以对字符串A，用位运算（26bit整数表示)计算出一个“签名”，再用B中的字符到A里面进行查找。

```C
unsigned int bit_flag[100]={0};
void  my_bit_map(int num)
{
	int length=32;
	int m=num/length;
	int n=num%length;
	bit_flag[m] = bit_flag[m]  | (1<<n );
}

void print(unsigned int n)
{
	while (n)
	{
		cout<<n%2;
		n=n/2;
	}
}
```

## 字符串全排列

- 题目描述

输入一个字符串，打印出该字符串中字符的所有排列。

例如输入字符串abc，则输出由字符a. b. c 所能排列出来的所有字符串

abc. acb. bac. bca. cab 和 cba。


解法一. 递归实现

```c
void CalcAllPermutation(char* perm, int from, int to)
{
	if (to <= 1)
	{
		return;
	}

	if (from == to)
	{
		for (int i = 0; i <= to; i++)
			cout << perm[i];
		cout << endl;
	}
	else
	{
		for (int j = from; j <= to; j++)
		{
			swap(perm[j], perm[from]);
			CalcAllPermutation(perm, from + 1, to);
			swap(perm[j], perm[from]);
		}
	}
}

int main()
{
	char perm[3]={'a','b','c'};
	CalcAllPermutation(perm,0,2);
	return 1;
}

```

- 核心部分

```c
for (int j = from; j <= to; j++)
{
	swap(perm[j], perm[from]);
	CalcAllPermutation(perm, from + 1, to);
	swap(perm[j], perm[from]);
}
```

a,b,c. 将后面的每个单词和第一个单词交换.都尝试下.
尝试完交换回来.



解法二. 字典序排列

采用字典序方法,通过计算出下一个排列的方法得到所有的排列.

- 总结

由于全排列总共有n!种排列情况，所以不论解法一中的递归方法，还是上述解法二的字典序排列方法，这两种方法的时间复杂度都为O(n!)。


## 字符串转换为整数

题目描述

输入一个由数字组成的字符串，把它转换成整数并输出。例如：输入字符串"123"，输出整数123。

给定函数原型int StrToInt(const char *str) ，实现字符串转换成整数的功能，不能使用库函数atoi。



1. 指针输入：输入的是指针，在访问空指针时程序会崩溃，因此在使用指针之前需要先判断指针是否为空。
1. 正负符号：整数不仅包含数字，还有可能是以'+'或'-'开头表示正负整数，因此如果第一个字符是'-'号，则要把得到的整数转换成负整数。
1. 非法字符：输入的字符串中可能含有不是数字的字符。因此，每当碰到这些非法的字符，程序应停止转换。
1. 整型溢出：输入的数字是以字符串的形式输入，因此输入一个很长的字符串将可能导致溢出。


## 回文判断

题目描述

回文，英文palindrome，指一个顺着读和反过来读都一样的字符串，比如madam. 我爱我，这样的短句在智力性. 趣味性和艺术性上都颇有特色，中国历史上还有很多有趣的回文诗。

那么，我们的第一个问题就是：判断一个字串是否是回文？

解法一

同时从字符串头尾开始向中间扫描字串.

```c
bool IsPalindrome(const char *s, int n)
{
    // 非法输入
    if (s == NULL || n < 1)
    {
        return false;
    }
    const char* front,*back;

    // 初始化头指针和尾指针
    front = s;
    back = s+ n - 1;

    while (front < back)
    {
        if (*front != *back)
        {
            return false;
        }
        ++front;
        --back;
    }
    return true;
}

```
这是一个直白且效率不错的实现，时间复杂度：O(n)，空间复杂度：O(1)。


## 最长回文子串

题目描述

给定一个字符串，求它的最长回文子串的长度。


解法一 中心扩展法

那么如何高效的进行判断呢？我们想想，如果一段字符串是回文，那么以某个字符为中心的前缀和后缀都是相同的，例如以一段回文串“aba”为例，以b为中心，它的前缀和后缀都是相同的，都是a。

那么，我们是否可以可以枚举中心位置，然后再在该位置上用扩展法，记录并更新得到的最长的回文长度呢？答案是肯定的，参考代码如下：


```c
int LongestPalindrome(const char *s, int n)
{
    int i, j, max,c;
    if (s == 0 || n < 1)
        return 0;
    max = 0;
    for (i = 0; i < n; ++i) { // i is the middle point of the palindrome  
        for (j = 0; (i - j >= 0) && (i + j < n); ++j){ // if the length of the palindrome is odd  
            if (s[i - j] != s[i + j])
                break;
            c = j * 2 + 1;
        }
        if (c > max)
            max = c;
        for (j = 0; (i - j >= 0) && (i + j + 1 < n); ++j){ // for the even case  
            if (s[i - j] != s[i + j + 1])
                break;
            c = j * 2 + 2;
        }
        if (c > max)
            max = c;
    }
    return max;
}
```

代码稍微难懂一点的地方就是内层的两个 for 循环，它们分别对于以 i 为中心的，长度为奇数和偶数的两种情况，整个代码遍历中心位置 i 并以之扩展，找出最长的回文。



解法二. O(N)解法

Manacher算法

```c
#include<iostream>
#include<vector>
using namespace std;
//
void fun(char input[],int n)
{
	char* s=new char[2*n+2];
	int* p=new int[2*n+2];
	int maxcount=-1;//最长回文长度
	int pos=-1;//回文中心位置
	int count=1;
	s[0]='$';
	s[1]='#';
	for (int i=0;i<n;i++)
	{
		count++;
		s[count]=input[i];
		count++;
		s[count]='#';
	}

	for (int i=0;i<2*n+2;i++)
	{
		cout<<s[i];
	}
	cout<<endl;

	int mx = 0;
	int id = 0;
	for (int i = 0;i<(2*n+2); i++) 
	{
		if ( mx > i)
		{
			p[i]=min(mx-i,p[2*id-i]);
		}
		else
		{
			p[i]=1;
		}

		while(s[i+p[i]]==s[i-p[i]]  && (i+p[i])<(2*n+2)  && (i-p[i])>=0)
		{
			p[i]++;
		}

		if (p[i]+i > mx)
		{
			mx=p[i]+i;
			id=i;
		}

	}

	for (int i=0;i<2*n+2;i++)
	{
		if(p[i]>maxcount)
		{
			maxcount=p[i];
			pos=i;
		}
	}
	cout<<"pos:"<<pos<<"  length:"<<p[pos]<<endl;
}

int main()
{
	char perm[6]={'d','a','b','c','b','a'};
	fun(perm,6);	
	return 1;
}
```

此外，为了进一步减少编码的复杂度，可以在字符串的开始加入另一个特殊字符，这样就不用特殊处理越界问题，比如$#a#b#a#。


![](http://i.imgur.com/5HD3BNy.png)

此Manacher算法使用id. mx做配合，可以在每次循环中，直接对P[i]的快速赋值，从而在计算以i为中心的回文子串的过程中，不必每次都从1开始比较，减少了比较次数，最终使得求解最长回文子串的长度达到线性O(N)的时间复杂度。


空间复杂度：插入分隔符形成新串，占用了线性的空间大小；RL数组也占用线性大小的空间，因此空间复杂度是线性的。
时间复杂度：尽管代码里面有两层循环，通过amortized analysis我们可以得出，Manacher的时间复杂度是线性的。由于内层的循环只对尚未匹配的部分进行，因此对于每一个字符而言，只会进行一次，因此时间复杂度是O(n)。


## [最长公共子序列](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/blob/master/ebook/zh/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.md)

- 问题描述 

 什么是最长公共子序列呢?好比一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S 称为已知序列的最长公共子序列。

举个例子，如：有两条随机序列，如 1 3 4 5 5 ，and 2 4 5 5 7 6，则它们的最长公共子序列便是：4 5 5。

**子序列不一定连续**

注意最长公共子串（Longest CommonSubstring）和最长公共子序列（LongestCommon Subsequence, LCS）的区别：子串（Substring）是串的一个连续的部分，子序列（Subsequence）则是从不改变序列的顺序，而从序列中去掉任意的元素而获得的新序列；更简略地说，前者（子串）的字符的位置必须连续，后者（子序列LCS）则不必。比如字符串acdfg同akdfc的最长公共子串为df，而他们的最长公共子序列是adf。LCS可以使用动态规划法解决。下文具体描述。

解法一

最容易想到的算法是穷举搜索法，即对X的每一个子序列，检查它是否也是Y的子序列，从而确定它是否为X和Y的公共子序列，并且在检查过程中选出最长的公共子序列。X和Y的所有子序列都检查过后即可求出X和Y的最长公共子序列。X的一个子序列相应于下标序列{1, 2, …, m}的一个子序列，因此，X共有2m个不同子序列（Y亦如此，如为2^n），从而穷举搜索法需要指数时间（2^m * 2^n）。



记：
Xi=﹤x1，⋯，xi﹥即X序列的前i个字符 (1≤i≤m)（前缀）

Yj=﹤y1，⋯，yj﹥即Y序列的前j个字符 (1≤j≤n)（前缀）

假定Z=﹤z1，⋯，zk﹥∈LCS(X , Y) 。

- 若xm=yn（最后一个字符相同），则不难用反证法证明：该字符必是X与Y的任一最长公共子序列Z（设长度为k）的最后一个字符，即有zk = xm = yn 且显然有Zk-1∈LCS(Xm-1 , Yn-1)即Z的前缀Zk-1是Xm-1与Yn-1的最长公共子序列。此时，问题化归成求Xm-1与Yn-1的LCS（LCS(X , Y)的长度等于LCS(Xm-1 , Yn-1)的长度加1）。

- 若xm≠yn，则亦不难用反证法证明：要么Z∈LCS(Xm-1, Y)，要么Z∈LCS(X , Yn-1)。由于zk≠xm与zk≠yn其中至少有一个必成立，若zk≠xm则有Z∈LCS(Xm-1 , Y)，类似的，若zk≠yn 则有Z∈LCS(X , Yn-1)。此时，问题化归成求Xm-1与Y的LCS及X与Yn-1的LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的长度, LCS(X , Yn-1)的长度}。

由于上述当xm≠yn的情况中，求LCS(Xm-1 , Y)的长度与LCS(X , Yn-1)的长度，这两个问题不是相互独立的：两者都需要求LCS(Xm-1，Yn-1)的长度。另外两个序列的LCS中包含了两个序列的前缀的LCS，故问题具有最**优子结构性质考虑用动态规划法。**


**由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。**

也就是说，解决这个LCS问题，你要求三个方面的东西：1. LCS(Xm-1，Yn-1)+1；2. LCS(Xm-1，Y)，LCS(X，Yn-1)；3. max{LCS(Xm-1, Y)，LCS(X, Yn-1)}。

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/11/11.1.jpg)


**核心**

```c
if( x[i]=y[j] )
{
	c[i,j]=c[i-1,j-1]+1;
}else
{
c[i,j]:=Max( c[i,j-1],c[i-1,j] );
}
```

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/11/11.2.jpg)

c存储长度,b存储方向数据.沿着b的方向得到最长序列.打印"↖"即可找到.

```c
begin  
  m:=length[X];  
  n:=length[Y];  
  for i:=1 to m do c[i,0]:=0;
  for j:=1 to n do c[0,j]:=0;
      for i:=1 to m do  
        for j:=1 to n do  
            if x[i]=y[j] then  
              begin  
                c[i,j]:=c[i-1,j-1]+1;  
                b[i,j]:="↖";  
              end  
            else if c[i-1,j]≥c[i,j-1] then  
              begin  
                c[i,j]:=c[i-1,j];  
                b[i,j]:="↑";  
              end  
            else  
              begin  
                c[i,j]:=c[i,j-1];  
                b[i,j]:="←"  
              end;  
  return(c,b);  
end;  
```

### 算法改进

动态规划的一个计算最长公共子序列的方法如下，以两个序列 X. Y 为例子：

设有二维数组 f[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有：

```
f[1][1] = same(1,1)
f[i][j] = max{f[i − 1][j − 1] +same(i,j), f[i − 1][j] ,f[i][j − 1]}
```

其中，same(a,b)当 X 的第 a 位与 Y 的第 b 位完全相同时为“1”，否则为“0”。

此时，f[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。

该算法的空间. 时间复杂度均为O(n2)，经过优化后，空间复杂度可为O(n)，时间复杂度为O(nlogn)。


- 举一反三

1. 最长递增子序列LIS（Longest Increasing Subsequence）

给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4。

分析：其实此LIS问题可以转换成最长公子序列问题，为什么呢？

原数组为A {5， 6， 7， 1， 2， 8}
排序后：A‘{1， 2， 5， 6， 7， 8}
因为，原数组A的子序列顺序保持不变，而且排序后A‘本身就是递增的，这样，就保证了两序列的最长公共子序列的递增特性。如此，若想求数组A的最长递增子序列，其实就是求数组A与它的排序数组A‘的最长公共子序列。

# 2数组


## 2.1 寻找最小的k个数

题目描述

输入n个整数，输出其中最小的k个。

解法一

要求一个序列中最小的k个数，按照惯有的思维方式，则是先对这个序列从小到大排序，然后输出前面的最小的k个数。

至于选取什么的排序方法，我想你可能会第一时间想到快速排序（我们知道，快速排序平均所费时间为n*logn），然后再遍历序列中前k个元素输出即可。因此，总的时间复杂度：O（n * log n)+O(k)=O（n * log n）。


解法二

咱们再进一步想想，题目没有要求最小的k个数有序，也没要求最后n-k个数有序。既然如此，就没有必要对所有元素进行排序。这时，咱们想到了用选择或交换排序，即：

1. 遍历n个数，把最先遍历到的k个数存入到大小为k的数组中，假设它们即是最小的k个数；
2. 对这k个数，利用选择或交换排序找到这k个元素中的最大值kmax（找最大值需要遍历这k个数，时间复杂度为O（k））；
3. 继续遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与kmax比较：如果x < kmax ，用x替换kmax，并回到第二步重新找出k个元素的数组中最大元素kmax‘；如果x >= kmax，则继续遍历不更新数组。

每次遍历，更新或不更新数组的所用的时间为O（k）或O（0）。故整趟下来，时间复杂度为n*O（k）=O（n*k）。


解法三

更好的办法是维护容量为k的最大堆，原理跟解法二的方法相似：

1. 用容量为k的最大堆存储最先遍历到的k个数，同样假设它们即是最小的k个数；
2. 堆中元素是有序的，令k1<k2<...<kmax（kmax设为最大堆中的最大元素）
3. 遍历剩余n-k个数。假设每一次遍历到的新的元素的值为x，把x与堆顶元素kmax比较：如果x < kmax，用x替换kmax，然后更新堆（用时logk）；否则不更新堆。
这样下来，总的时间复杂度:O（k+（n-k）*logk）=** O（n*logk）**。此方法得益于堆中进行查找和更新的时间复杂度均为：O(logk)（若使用解法二：在数组中找出最大元素，时间复杂度：O（k））。

解法四

在《数据结构与算法分析--c语言描述》一书，第7章第7.7.6节中，阐述了一种在平均情况下，时间复杂度为O（N）的快速选择算法。如下述文字：

- 选取S中一个元素作为枢纽元v，将集合S-{v}分割成S1和S2，就像快速排序那样
- 如果k <= |S1|，那么第k个最小元素必然在S1中。在这种情况下，返回QuickSelect(S1, k)。
- 如果k = 1 + |S1|，那么枢纽元素就是第k个最小元素，即找到，直接返回它。
- 否则，这第k个最小元素就在S2中，即S2中的第（k - |S1| - 1）个最小元素，我们递归调用并返回QuickSelect(S2, k - |S1| - 1)。

此算法的平均运行时间为O(n)。


**更进一步，《算法导论》第9章第9.3节介绍了一个最坏情况下亦为O(n)时间的SELECT算法，有兴趣的读者可以参看。**

## 2.2 寻找和为定值的两个数

题目描述

输入一个数组和一个数字，在数组中查找两个数，使得它们的和正好是输入的那个数字。

要求时间复杂度是O(N)。如果有多对数字的和等于输入的数字，输出任意一对即可。

例如输入数组1. 2. 4. 7. 11. 15和数字15。由于4+11=15，因此输出4和11。

解法一

根据前面的分析，a[i]在序列中，如果a[i]+a[k]=sum的话，那么sum-a[i]（a[k])也必然在序列中。 举个例子，如下： 原始序列：

1.  2.  4.  7. 11. 15
用输入数字15减一下各个数，得到对应的序列为：

14. 13. 11. 8. 4.  0
第一个数组以一指针i 从数组最左端开始向右扫描，第二个数组以一指针j 从数组最右端开始向左扫描，如果第一个数组出现了和第二个数组一样的数，即a[i]=a[j]，就找出这俩个数来了。 如上，i，j最终在第一个，和第二个序列中找到了相同的数4和11，所以符合条件的两个数，即为4+11=15。 怎么样，两端同时查找，时间复杂度瞬间缩短到了O(N)，但却同时需要O(N)的空间存储第二个数组。

解法二

当题目对时间复杂度要求比较严格时，我们可以考虑下用空间换时间，上述解法一即是此思想，此外，构造hash表也是典型的用空间换时间的处理办法。

即给定一个数字，根据hash映射查找另一个数字是否也在数组中，只需用O(1)的时间，前提是经过O(N)时间的预处理，和用O(N)的空间构造hash表。

但能否做到在时间复杂度为O(N)的情况下，空间复杂度能进一步降低达到O(1)呢？

解法三

如果数组是无序的，**先排序(N log N)**，然后用两个指针i，j，各自指向数组的首尾两端，令i=0，j=n-1，然后i++，j--，逐次判断a[i]+a[j]?=sum，

如果某一刻a[i]+a[j] > sum，则要想办法让sum的值减小，所以此刻i不动，j--；
如果某一刻a[i]+a[j] < sum，则要想办法让sum的值增大，所以此刻i++，j不动。
所以，数组无序的时候，时间复杂度最终为O(N log N + N)=O(N log N)。



## 2.3 寻找和为定值的多个数

题目描述

输入两个整数n和sum，从数列1，2，3.......n 中随意取几个数，使其和等于sum，要求将其中所有的可能组合列出来。


[背包问题九讲](http://love-oriented.com/pack/)




## 2.4 最大连续子数组和


题目描述

输入一个整形数组，数组里有正数也有负数。数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。 求所有子数组的和的最大值，要求时间复杂度为O(n)。

例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2， 因此输出为该子数组的和18。

解法一

三个for循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组的最大的一个值。

```c
int MaxSubArray(int* A, int n)
{
    int maxSum = a[0];  //全负情况，返回最大负数
    int currSum = 0;
    for (int i = 0; i < n; i++)
    {
        for (int j = i; j < n; j++)
        {
            for (int k = i; k <= j; k++)
            {
                currSum += A[k];
            }
            if (currSum > maxSum)
                maxSum = currSum;

            currSum = 0; //这里要记得清零，否则的话sum最终存放的是所有子数组的和。
        }
    }
    return maxSum;
}
```



解法二


currSum 表示以j为结尾的连续子字符的和. 
**只有前面的大于0,才继续加**

1. 当currSum大于0, currSum += a[j];
1. 当currSum<0,currSum=a[j]



currSum = max(a[j], currSum + a[j])
maxSum = max(maxSum, currSum)
举个例子，当输入数组是1, -2, 3, 10, -4, 7, 2, -5，那么，currSum和maxSum相应的变化为：

currSum： 0 1 - 1 3 13 9 16 18 13
maxSum ： 0 1 1 3 13 13 16 18 18

## 2.5 跳台阶

题目描述

一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。

解法一

求总共有多少总跳法，并分析算法的时间复杂度。

当n>2时，第一次跳的时候就有两种不同的选择：
一是第一次只跳1级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)；
另外一种选择是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2)。
因此n级台阶时的不同跳法的总数f(n)=f(n-1)+f(n-2)。


解法二

从前往后算

//1, 1, 2, 3, 5, 8, 13, 21..
int ClimbStairs(int n)
{
    int dp[3] = { 1, 1 };
    if (n < 2)
    {
        return 1;
    }
    for (int i = 2; i <= n; i++)
    {
        dp[2] = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = dp[2];
    }
    return dp[2];
}


## 2.6 奇偶排序

题目描述

输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。要求时间复杂度为O(n)。

```c
//判断是否为奇数
bool IsOddNumber(int data)
{
    return data & 1 == 1;
}
```

方法一

借鉴partition的实现一，我们可以考虑维护两个指针，一个指针指向数组的第一个数字，我们称之为头指针，向右移动；一个指针指向最后一个数字，称之为尾指针，向左移动。

这样，两个指针分别从数组的头部和尾部向数组的中间移动，如果第一个指针指向的数字是偶数而第二个指针指向的数字是奇数，我们就交换这两个数字。





## 2.7 荷兰国旗

- 题目描述

该问题本身是关于三色球排序和分类的，由荷兰科学家Dijkstra提出。由于问题中的三色小球有序排列后正好分为三类，Dijkstra就想象成他母国的国旗，于是问题也就被命名为荷兰旗问题（Dutch National Flag Problem）。

下面是问题的正规描述： 现有n个红白蓝三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左至右，依次是一些红球. 一些白球. 一些蓝球。

通过前面的分析得知，这个问题类似快排中partition过程，只是需要用到三个指针：一个前指针begin，一个中指针current，一个后指针end，current指针遍历整个数组序列，当

current指针所指元素为0时，与begin指针所指的元素交换，而后current++，begin++ ；
current指针所指元素为1时，不做任何交换（即球不动），而后current++ ；
current指针所指元素为2时，与end指针所指的元素交换，而后，**current指针不动**，end-- 。
为什么上述第3点中，current指针所指元素为2时，与end指针所指元素交换之后，current指针不能动呢？因为第三步中current指针所指元素与end指针所指元素交换之前，如果end指针之前指的元素是0，那么与current指针所指元素交换之后，current指针此刻所指的元素是0，此时，current指针能动么？不能动，因为如上述第1点所述，如果current指针所指的元素是0，还得与begin指针所指的元素交换。

借鉴了快速排序的方法

![](https://camo.githubusercontent.com/39648f0f0b2a257306d5560958a2d79a5d5367a8/687474703a2f2f68692e6373646e2e6e65742f6174746163686d656e742f3230313130322f32352f383339343332335f31323938363431323235654a34462e6a7067)


## 2.8 矩阵相乘


## 2.9 完美洗牌


题目详情

有个长度为2n的数组{a1,a2,a3,...,an,b1,b2,b3,...,bn}，希望排序后{a1,b1,a2,b2,....,an,bn}，请考虑有无时间复杂度o(n)，空间复杂度0(1)的解法。

题目来源：此题是去年2013年UC的校招笔试题，看似简单，按照题目所要排序后的字符串蛮力变化即可，但若要完美的达到题目所要求的时空复杂度，则需要我们花费不小的精力。OK，请看下文详解，一步步优化。


# 3树

2–3树是一个这样的一棵树， 它的每个节点要么有2个孩子和1个数据元素，要么有3个孩子和2个数据元素，叶子节点没有孩子，并且有1个或2个数据元素。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/2-3-4_tree_2-node.svg/110px-2-3-4_tree_2-node.svg.png)

![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/2-3-4-tree_3-node.svg/120px-2-3-4-tree_3-node.svg.png)

## 3.0统计出现次数最多的数据

题目描述

千万或上亿的数据,数据有重复,统计其中出现次数最多的前n个数据.



解法一 hash_map

hash_map 统计次数. 堆取出前n个数据.


解法二 红黑树

红黑树进行频率统计.利用堆取出前n个数据.

红黑树广泛应用.

C++,STL  set,map,muliset,mulimap.底层都是基于红黑树的.


二叉查找树操作

平均复杂度O(logn)  最坏O(n)


红黑树,本质上来说就是一棵二叉查找树,增加了着色和相关的性质使得红黑树相对平衡，从而保证了**红黑树的查找. 插入. 删除的时间复杂度最坏为O(log n)。**

性质:

1. 每个结点要么是红的，要么是黑的。  
2. 根结点是黑的。  
3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。  
4. 如果一个结点是红的，那么它的俩个儿子都是黑的。  
5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的**黑结点。**

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/rbtree/1.png)

[红黑树 插入 删除操作](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md)

## 3.1 红黑树
## 3.2 B树

题目描述

硬盘上有一个文本文件,一行一个人名. 找出"jason"的人.

许多数据库.都使用了B树或B树的各种变形结构

树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，因此我们该想办法降低树的深度，从而减少磁盘查找存取的次数。一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/7/1.jpg)


一棵含n个结点的B树的高度也为O(lgn)，但可能比一棵红黑树的高度小许多，因为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/7/2.jpg)

B树的定义

B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：

1. 树中每个结点最多含有m个孩子（m>=2）；
1. 除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；
1. 根结点至少有2个孩子（除非B树只包含一个结点：根结点）；
1. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，指向这些结点的指针都为null)；（注：叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。类似红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。
1. 每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
	a) Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。
	b) Pi为指向子树根的结点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。
	c) 关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。比如有j个孩子的非叶结点恰好有j-1个关键码。



- 插入操作

1. 如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；
2. 如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。
3. 此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。


- 删除操作

是否有左右孩子结点

1. 如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)1. 到父节点中，然后是移动之后的情况；
1. 如果没有，直接删除后，移动之后的情况。

删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于ceil(m/2)-1，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）

1. 如果丰满，则向父节点借一个元素来满足条件；
1. 如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于ceil(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。

### B+树

一棵m阶的B+树和m阶的B树的异同点在于：

1. 有n棵子树的结点中含有n-1 个关键字； (与B 树n棵子树有n-1个关键字 保持一致，参照：http://en.wikipedia.org/wiki/B%2B_tree#Overview，而下面B+树的图可能有问题，请读者注意)
1. 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)
1. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

B+树的叶子节点时数据. 非终端节点是索引信息.

B+树的好处.


1. 磁盘读写代价.节点数据少.一次读的数据量大,IO次数少.
1. 查询更加稳定,所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
1. 变量叶子节点可以实现整棵树遍历

总而言之，B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。
正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询，而B树不支持range-query这样的操作（或者说效率太低）。

### B*树

![](https://github.com/StarryNight678/The-Art-Of-Programming-By-July/raw/master/ebook/images/7/10.jpg)

B*-tree是B+-tree的变体，在B+树的基础上(所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针)，B*树中非根和非叶子结点再增加指向兄弟的指针；B*树定义了非叶子结点关键字个数至少为(2/3)*M，
即块的最低使用率为2/3（代替B+树的1/2）。

 
## 3.3 最近公共祖先LCA

问题描述

求有根树的任意两个节点的最近公共祖先。LCA（Lowest Common Ancestor）

解法一

那么从树根开始：

1. 如果当前结点t 大于结点u. v，说明u. v都在t 的左侧，所以它们的共同祖先必定在t 的左子树中，故从t 的左子树中继续查找；
1. 如果当前结点t 小于结点u. v，说明u. v都在t 的右侧，所以它们的共同祖先必定在t 的右子树中，故从t 的右子树中继续查找；
1. 如果当前结点t 满足 u <t < v，说明u和v分居在t 的两侧，故当前结点t 即为最近公共祖先；

注意:而如果u是v的祖先，那么返回u的父结点，同理，如果v是u的祖先，那么返回v的父结点。




# 4查找


## 4.1 有序数组的查找

题目描述

给定一个有序的数组，查找某个数是否在数组中，请编程实现。

二分查找,log(n)

```c
int BinarySearch(int array[], int n, int value)
{
    int left = 0;
    int right = n - 1;
    //如果这里是int right = n 的话，那么下面有两处地方需要修改，以保证一一对应：
    //1. 下面循环的条件则是while(left < right)
    //2. 循环内当 array[middle] > value 的时候，right = mid

    while (left <= right)  //循环条件，适时而变
    {
        int middle = left + ((right - left) >> 1);  //防止溢出，移位也更高效。同时，每次循环都需要更新。

        if (array[middle] > value)
        {
            right = middle - 1;  //right赋值，适时而变
        }
        else if(array[middle] < value)
        {
            left = middle + 1;
        }
        else
            return middle;
        //可能会有读者认为刚开始时就要判断相等，但毕竟数组中不相等的情况更多
        //如果每次循环都判断一下是否相等，将耗费时间
    }
    return -1;
}
```

## 4.2 行列递增矩阵的查找

题目描述

在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

例如下面的二维数组就是每行. 每列都递增排序。如果在这个数组中查找数字6，则返回true；如果查找数字5，由于数组不含有该数字，则返回false。

方法一

对角线递增,通过对角线元素进行,二分查找.

方法二


从最右上角进行查询.按照大小,向左和向下走.




## 4.3 出现次数超过一半的数字

题目描述

题目：数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。

方法一 排序

一个数字在数组中的出现次数超过了一半，那么在已排好序的数组索引的N/2处（从零开始编号），就一定是这个数字。

方法二 哈希

O(n)



解法三

每次删除两个不同的数

解法四

更进一步，考虑到这个问题本身的特殊性，我们可以在遍历数组的时候保存两个值：一个candidate，用来保存数组中遍历到的某个数字；一个nTimes，表示当前数字的出现次数，其中，nTimes初始化为1。当我们遍历到数组中下一个数字的时候：

1. 如果下一个数字与之前candidate保存的数字相同，则nTimes加1；
1. 如果下一个数字与之前candidate保存的数字不同，则nTimes减1；
1. 每当出现次数nTimes变为0后，用candidate保存下一个数字，并把nTimes重新设为1。 直到遍历完数组中的所有数字为止。


# 5动态规划


## 5.1 最大连续乘积子串

题目描述

给一个浮点数序列，取最大乘积连续子串的值，例如 -2.5，4，0，3，0.5，8，-1，则取出的最大乘积连续子串为3，0.5，8。也就是说，上述数组中，3 0.5 8这3个数的乘积30.58=12是最大的，而且是连续的。




## 5.2 字符串编辑距离
## 5.3 格子取数
## 5.4 交替字符串
## 5.10 本章习题

# 6海量数据处理

事实上，针对时间问题，可以采用巧妙的算法搭配合适的数据结构
（如布隆过滤器. 哈希. 位图. 堆. 数据库. 倒排索引. Trie树）来解决；

而对于空间问题，可以采取分而治之（哈希映射）的方法，也就是说，
把规模大的数据转化为规模小的，从而各个击破。


一般说来，处理海量数据问题，有以下十种典型方法：

1. 哈希分治；
2. simhash算法；
3. 外排序；
4. MapReduce；
5. 多层划分；
6. 位图；
7. 布隆过滤器
8. Trie树；
9. 数据库；
10. 倒排索引。


## 6.0 本章导读
## 6.1 关联式容器
## 6.2 分而治之
## 6.3 simhash算法
## 6.4 外排序
## 6.5 MapReduce
## 6.6 多层划分
## 6.7 Bitmap

在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

解法一：采用2-Bitmap（每个数分配2bit，**00表示不存在，01表示出现一次，10表示多次，11无意义**）
进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。


Bitmap 可以采用多位进行测试. 00,01,10,11

## 6.8 Bloom filter

散列函数弊端,存储空间太大.

通过极小的误判,换来存储空间极大节省.

散列函数个数最优值  k=m/n*ln2=(0.7*m/n)

m bit空间,k个哈希函数, n个值.

![](http://img2016.itdadao.com/d/file/tech/2016/09/11/cd310923110043258.png)

确定m后,n的值大约是(n=m*[5-10])

## 6.9 Trie树
## 6.10 数据库

## 6.11 倒排索引


以英文为例，下面是要被索引的文本：

```
T0 = "it is what it is"  
T1 = "what is it"  
T2 = "it is a banana"  
我们就能得到下面的反向文件索引：
```

```
"a":      {2}
"banana": {2}
"is":     {0, 1, 2}
"it":     {0, 1, 2}
"what":   {0, 1}
```

倒排索引,指向包含该单词的文件.

## 6.15 Simhash算法

查找文章间相似度.hash函数应该是相似内容产生相似hash值.

[使用SimHash进行海量文本去重](http://www.cnblogs.com/maybe2030/p/5203186.html)


![](http://images2015.cnblogs.com/blog/764050/201602/764050-20160220122034206-345045199.png)

1. 分词，把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==> 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。


2. hash，通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。

3. 加权，通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。

4. 合并，把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。

5. 降维，把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。


- 距离计算

我们把库里的文本都转换为simhash签名，并转换为long类型存储，空间大大减少。现在我们虽然解决了空间，但是如何计算两个simhash的相似度呢？难道是比较两个simhash的01有多少个不同吗？对的，其实也就是这样，我们通过海明距离（Hamming distance）就可以计算出两个simhash到底相似不相似。两个simhash对应二进制（01串）取值不同的数量称为这两个simhash的海明距离。举例如下： 10101 和 00110 从第一位开始依次有第一位. 第四. 第五位不同，则海明距离为3。对于二进制字符串的a和b，海明距离为等于在a XOR b运算结果中1的个数（普遍算法）。

- 查找相同

分成四段,建立倒排索引.

# 7机器学习

## 7.1 K 近邻算法
## 7.2 支持向量机
## 附录 更多题型

## 附录A 语言基础

语言基础

1. C++中虚拟函数的实现机制。

2. 指针数组和数组指针的区别。

3. malloc-free和new-delete的区别。

4. sizeof和strlen的区别。

5. 描述函数调用的整个过程。

6. C++ STL里面的vector的实现机制，

	- 当调用push_back成员函数时，怎么实现？

	内存足则直接 placement new构造对象，否则扩充内存，转移对象，新对象placement new上去。

	- 当调用clear成员函数时，做什么操作，如果要释放内存该怎么做。
	调用析构函数，内存不释放。 clear没有释放内存，只是将数组中的元素置为空了，释放内存需要delete。


## 附录B 概率统计
## 附录C 智力逻辑
## 附录D 系统设计
## 附录E 操作系统
## 附录F 网络协议


- 请问死锁的条件是什么？以及如何处理死锁问题？

解答：互斥条件（Mutual exclusion）：

1.  资源不能被共享，只能由一个进程使用。
2.  请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
3.  非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
4.  循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。


- 请阐述动态链接库与静态链接库的区别。

解答：静态链接库是.lib格式的文件，一般在工程的设置界面加入工程中，程序编译时会把lib文件的代码加入你的程序中因此会增加代码大小，你的程序一运行lib代码强制被装入你程序的运行空间，不能手动移除lib代码。

动态链接库是程序运行时动态装入内存的模块，格式*.dll，在程序运行时可以随意加载和移除，节省内存空间。

在大型的软件项目中一般要实现很多功能，如果把所有单独的功能写成一个个lib文件的话，程序运行的时候要占用很大的内存空间，导致运行缓慢；但是如果将功能写成dll文件，就可以在用到该功能的时候调用功能对应的dll文件，不用这个功能时将dll文件移除内存，这样可以节省内存空间

- 请阐述进程与线程的区别。

解答：

从概念上：
进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。
线程：一个进程内的基本调度单位。线程的划分尺度小于进程，一个进程包含一个或者更多的线程。

从执行过程中来看：
进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。
线程：每一个独立的线程，都有一个程序运行的入口.  顺序执行序列.  和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

从逻辑角度来看（重要区别）：
多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。


- 用户进程间通信主要哪几种方式？

解答：主要有以下6种：

1.  管道：管道是单向的.  先进先出的.  无结构的.  固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的道端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。
无名管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（通常是指父子进程关系）的进程间使用。
命名管道：命名管道也是半双工的通信方式，在文件系统中作为一个特殊的设备文件而存在，但是它允许无亲缘关系进程间的通信。当共享管道的进程执行完所有的I/O操作以后，命名管道将继续保存在文件系统中以便以后使用。
2.  信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
3.  消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少.  管道只能承载无格式字节流以及缓冲区大小受限等缺点。
4.  信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
5.  共享内存：共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其它进程间通信方式运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。
6.  套接字：套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。